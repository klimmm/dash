================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-10-31T14:28:23.732Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
app/
  __init__.py
  app_layout.py
  checklist.py
  date_range_filter.py
  dropdown.py
  filter_values_callbacks.py
  table_styles.py
app.py

================================================================
Repository Files
================================================================

================
File: app/__init__.py
================
import sys
import os

import logging

import dash
from dash import dash_table, Input, Output, callback, html, dcc
from dash.exceptions import PreventUpdate
from dash.dash_table.Format import Format, Scheme, Group, Sign

import dash_bootstrap_components as dbc

import pandas as pd
import numpy as np
from typing import Any, Callable, Dict, List, Optional, Tuple
import traceback
import json

from config import APP_TITLE, DEBUG_MODE, PORT, DATA_FILE_NEW, DATA_FILE_REINSURANCE, LINES_DICTIONARY, INSURERS_DICTIONARY, LINES_158_DICTIONARY, DASH_CONFIG

from logging_config import setup_logging, get_logger, debug_log, intensive_debug_log, set_debug_level, DebugLevels, custom_profile
#from .layout_callbacks import setup_layout_callbacks
from .checklist import setup_checklist_callbacks, CategoryChecklist

from .date_range_filter import setup_layout_callbacks


from data_process.table_data import get_data_table
from data_process.update_filter_options import get_filter_options

from data_process.data_utils import create_year_quarter_options, load_and_preprocess_data, save_df_to_csv, log_dataframe_info, print_dataframe_info, load_json, log_chart_structure, process_inputs
#from data_process.process_market_metrics import process_market_metrics
from data_process.chart_data import get_chart_data

from .app_layout import create_app_layout, setup_tab_state_callbacks, setup_button_callbacks #, setup_filter_callbacks #, setup_layout_callbacks, setup_tab_state_callbacks
#from .tab_state_callbacks import setup_tab_state_callbacks
from app.filter_values_callbacks import setup_filter_values_callbacks

from data_process.update_filter_options import get_filter_options
from data_process.process_filters import MetricsProcessor #process_general_filters
#from data_process.process_df import get_processed_df

from charting.config import ChartConfig
from charting.chart import generate_chart_figure

from constants.translations import translate, translate_quarter

from constants.mapping import map_line, map_insurer
from constants.filter_options import (

    LINEMAIN_OPTIONS, PREMIUM_LOSS_OPTIONS, MARKET_METRIC_DROPDOWN_OPTIONS, PERIOD_TYPES_OPTIONS, 
    PRIMARY_METRICS_OPTIONS, SECONDARY_METRICS_OPTIONS, METRICS_OPTIONS,  LINEMAIN_COL, INSURER_COL, 
     REINSURANCE_FIG_TYPES, INSURANCE_FIG_TYPES,  CHART_TYPE_DROPDOWN_OPTIONS, 
    REINSURANCE_GRAPH_SWITCH_OPTIONS, REINSURANCE_FORM_DROPDOWN_OPTIONS, REINSURANCE_TYPE_DROPDOWN_OPTIONS, 
    REINSURANCE_GEOGRAPHY_DROPDOWN_OPTIONS,
    INSURANCE_COLUMN_SWITCH, INSURANCE_COLUMN_SWITCH_OPTIONS,
    VALUE_METRICS_OPTIONS, AVERAGE_VALUE_METRICS_OPTIONS, RATIO_METRICS_OPTIONS, MARKET_SHARE_METRICS_OPTIONS, Q_TO_Q_CHANGE_METRICS_OPTIONS,    
    ALL_METRICS_OPTIONS, REINSURANCE_METRIC_OPTIONS, REINSURANCE_COLUMN_SWITCH_OPTIONS,
    MAIN_METRICS_OPTIONS_TABLE, ADDITIONAL_METRICS_OPTIONS_TABLE, calculated_metrics_options
)

from default_values import (
    DEFAULT_PREMIUM_LOSS_TYPES, 
    DEFAULT_INSURER, DEFAULT_PRIMARY_METRICS, DEFAULT_SECONDARY_METRICS, 
    DEFAULT_TABLE_METRIC, DEFAULT_EXPANDED_CATEGORIES, DEFAULT_CHART_TYPE, DEFAULT_SECONDARY_CHART_TYPE, DEFAULT_X_COL_INSURANCE, DEFAULT_SERIES_COL_INSURANCE, DEFAULT_GROUP_COL_INSURANCE, DEFAULT_CHECKED_CATEGORIES, DEFAULT_AGGREGATION_TYPE )

================
File: app/app_layout.py
================
import dash
from dash import dcc, Input, Output, State, ALL, MATCH, dash_table, html
from dash.exceptions import PreventUpdate
import dash_bootstrap_components as dbc
from typing import List

from logging_config import get_logger
from .checklist import checklist_stores_row, create_checklist_row
from data_process.data_utils import default_insurer_options, category_structure
from default_values import *
from constants.filter_options import *
from constants.translations import translate
from .dropdown import create_dropdown_component
from .date_range_filter import create_date_range_selector, create_date_type_selector

logger = get_logger(__name__)
from logging_config import get_logger, custom_profile







def create_common_filters():
    """Create filters common to all modes (data table and charts)"""
    return html.Div([
        dbc.Row([
            dbc.Col(        
        
                html.Label("Вид страхования:", className="filter-label mb-2"),
            ),
            dbc.Col([
                html.Div([                
                
                    dbc.Button(
                        "Drill down", 
                        id="detailize-button", 
                        #color="primary", 
                        size="sm",
                        className="w-100 py-0 ms-1 btn-secondary-custom",  # py-0 removes vertical padding
                        style={"height": "26px"}  
                    ) 
                ], id="detailize-button-section"),
                
            ], className="ps-1"),

        ], className="mb-2 g-0"),
        create_dropdown_component(id='category-dropdown', xs=12, sm=12, md=12),
        # Linemains section
        dbc.Row([
            dbc.Col(
                dbc.Button(
                    "Показать все", 
                    id='toggle-all-categories', 
                    #color="primary", 
                    size="sm",
                    className="w-100 py-0 ms-1 btn-secondary-custom"  # py-0 removes vertical padding
                    #style={"height": "30px"}  # Explicitly set height
                ), 
                className="pe-1"
            ),
           
            

        ], className="mb-2 g-2"),
        dbc.Row([
            dbc.Col([checklist_stores_row], width=6),
            create_checklist_row(),
        ]),
        
        dbc.Row([
            dbc.Col([        
        
                html.Label("Показатель:", className="filter-label mb-0"),
            ], width=4, className="pe-0"),
            dbc.Col([        
                html.Div([
                            
                    # Premium/Loss Selection
                    dbc.Checklist(
                        id='premium-loss-checklist',
                        options=PREMIUM_LOSS_OPTIONS,
                        value=DEFAULT_PREMIUM_LOSS_TYPES,
                        inline=True,
                        className="filter-checklist filter-option mb-0"
                    ),                
        
                ], id="premium-loss-checklist-section", style={"display": "none"}, className="mb-0"),

            ], width=8, className="pe-0"),

        ], className="mb-2 g-0"),
                
        create_dropdown_component(id='primary-y-metric', xs=12, sm=12, md=12),
    ], id="common-filters", className="mb-3")


def create_chart_specific_filters():
    """Create filters specific to chart mode"""
    return 
    
    

def create_comparison_controls():
    return dbc.Row([
        html.Div([
            dbc.Button(
                "Сравнить...",
                id='comparison-toggle',
                color="primary",
                size="sm",
                className="w-100 py-0 ms-1 btn-custom",
                n_clicks=0
            ),

        ], style={"display": "inline-block"})

    ], className="g-0 mb-2")

def create_comparison_section():
    """Create comparison section with both comparison options"""
    return html.Div([
        html.Div([
        
            create_comparison_controls(),
            # Compare metrics section
            html.Div([
                create_dropdown_component(id='secondary-y-metric', xs=12, sm=12, md=12),
            ], id="compare-metrics-section", style={"display": "none"}, className="mb-1"),
                
            # Compare insurers section
            html.Div([
                create_dropdown_component(id='compare-insurers-main', xs=12, sm=12, md=12),
            ], id="compare-insurers-section", style={"display": "none"}, className="mb-1"),
            

    
    
            html.Div([
                dbc.Row([
                    dbc.Col([
    
                        html.Label("Диаграмма Y2:", className="filter-label mb-2 mt-3"),
                    ], width=4, className="pe-2"),
                    dbc.Col([
                        
                        create_dropdown_component('secondary-chart-type'),
                    ], width=8, className="pe-2"),
    
                ], className="g-0 mb-2 align-items-end"),  
                        
            ], id="secondary-chart-type-section", style={"display": "none"}, className="mb-1"),
    
        ], id="comparison-section", className="mb-3"),
    ], id="comparison-section-wrapper", className="mb-3")




def create_unified_date_controls(year_quarter_options, DEFAULT_START_QUARTER, DEFAULT_END_QUARTER, DEFAULT_NUMBER_OF_PERIODS):
    return dbc.Row([
        html.Label("Период:", className="filter-label"),
        dbc.Col(
            create_date_range_selector(year_quarter_options, DEFAULT_START_QUARTER, DEFAULT_END_QUARTER, DEFAULT_NUMBER_OF_PERIODS),
            width=6,
            className="pe-2"
        ),
        dbc.Col(
            create_date_type_selector(),
            width=6
        )
    ], className="align-items-center mb-2")

    
def create_chart_container():
    return html.Div([
        dcc.Store(id='chart-count', data=0),
        html.Div([
            html.Div(
                id='working-chart-container',
                className='working-chart-area',
                style={
                    'width': '100%',
                    'marginBottom': '30px'
                }
            ),
            html.Div(
                id='stored-charts-container',
                className='stored-charts-area',
                style={
                    'width': '100%',
                    'display': 'flex',
                    'flexDirection': 'column',
                    'gap': '20px'
                }
            )
        ],
        id='main-charts-container',
        style={
            'width': '100%',
            'height': '2000px',
            'display': 'flex',
            'flexDirection': 'column',
            'overflowY': 'auto',
            'padding': '20px'
        })
    ])





TOGGLE_BUTTONS = [
    ('group-series-toggle', "G", DEFAULT_SERIES_GROUP),
    ('stacking-series-toggle', "SS", DEFAULT_SERIES_STACK),
    ('stacking-groups-toggle', "SG", DEFAULT_GROUPS_STACK),
    ('show-percentage-toggle', "%", False),
    ('show-100-percent-toggle', "100%", False),
    ('random-color-toggle', "RC", False),
]


def create_create_chart_buttons_row():
    return html.Div([
        dbc.Row([
            # Dropdown buttons for X, S, G
            dbc.Col([
                dbc.Row([         
                    dbc.Col([
                        html.Div([
                            html.Label("X:", className="me-2 mb-0", 
                                     style={
                                         "color": "#999999", 
                                         "fontSize": "0.7rem",
                                         "lineHeight": "1"
                                     }),
                            html.Div(create_dropdown_component(id='x-column'), 
                                    className="chart-control-dropdown",  # Add specific class
                                    style={"width": "calc(100% - 25px)"})
                        ], style={"display": "flex", "alignItems": "center", "height": "20px"})
                    ], width=4, className="pe-1"),
                    
                    dbc.Col([
                        html.Div([
                            html.Label("S:", className="me-2 mb-0", 
                                     style={
                                         "color": "#999999", 
                                         "fontSize": "0.7rem",
                                         "lineHeight": "1"
                                     }),
                            html.Div(create_dropdown_component(id='series-column'), 
                                    className="chart-control-dropdown",  # Add specific class
                                    style={"width": "calc(100% - 25px)"})
                        ], style={"display": "flex", "alignItems": "center", "height": "20px"})
                    ], width=4, className="pe-1"),
                    
                    dbc.Col([
                        html.Div([
                            html.Label("G:", className="me-2 mb-0", 
                                     style={
                                         "color": "#999999", 
                                         "fontSize": "0.7rem",
                                         "lineHeight": "1"
                                     }),
                            html.Div(create_dropdown_component(id='group-column'), 
                                    className="chart-control-dropdown",  # Add specific class
                                    style={"width": "calc(100% - 25px)"})
                        ], style={"display": "flex", "alignItems": "center", "height": "20px"})
                    ], width=4, className="pe-1"),
                    
                ], className="g-0 mb-1 align-items-center"),
                
            ], width=5, className="pe-1"),  
            # Toggle buttons
            dbc.Col([
                dbc.Row([
                    *[dbc.Col(
                        dbc.Button(
                            label,
                            id=id,
                            className="py-0 toggle-btn w-100",  # Using your custom padding
                            size="sm",
                            n_clicks=0
                        ),
                        width=2,
                        className="pe-1"
                    ) for id, label, value in TOGGLE_BUTTONS],
                ], className="g-0"),
                
            ], width=5, className="pe-1"),
                
            # Add and Clear buttons
            dbc.Col(
                dbc.Button(
                    'Add',
                    id='store-chart-button',
                    size="sm",
                    className="py-0 toggle-btn toggle-btn-success w-100"  # Using your custom padding
                ),
                width=1,
                className="pe-1"
            ),
            dbc.Col(
                dbc.Button(
                    "Clear All",
                    id="clear-charts-button",
                    size="sm",
                    className="py-0 toggle-btn toggle-btn-danger w-100"  # Using your custom padding
                ),
                width=1
            ),
        ], className="g-0 mb-2 align-items-center"),
    ], id="charts-buttons")


    

from logging_config import get_logger, custom_profile
@custom_profile
def create_app_layout(year_quarter_options):
    try:
        layout = html.Div([
            dbc.Navbar(
                dbc.Container([
                    dbc.NavbarBrand("Insurance Data Dashboard", href="#"),
                    dbc.NavbarToggler(id="navbar-toggler"),
                    dbc.Collapse(
                        dbc.Row([
                            dbc.Col(
                                dbc.ButtonGroup([
                                    dbc.Button("Insurance", id="insurance-tab", color="light", className="me-1 tab-like-button active"),
                                    dbc.Button("Reinsurance", id="reinsurance-tab", color="light", className="tab-like-button"),
                                ], className="me-3"),
                                width="auto",
                            ),
                            dbc.Col(
                                html.Div([
                                    dbc.Button("Data Table", id="data-table-tab", color="light", className="tab-like-button"),
                                ], id="data-table-button-container"),
                                width="auto",
                            ),
                        ], className="ms-auto flex-nowrap mt-3 mt-md-0", align="center"),
                        id="navbar-collapse",
                        navbar=True,
                    ),
                ], fluid=True),
                color="primary",
                dark=True,
                className="mb-2"
            ),
            
            dbc.Container([
         
                html.Div(id='_hidden-init-trigger', style={'display': 'none'}),
                
                # Store components
                dcc.Store(id="show-reinsurance-chart", data=False),
                dcc.Store(id="show-data-table", data=False),
                dcc.Store(id="show-simple-filters", data=False),

                # Two-column layout
                dbc.Row([
                # Left column - All Filters
                    dbc.Col([
                        dbc.Card([
                            dbc.CardBody([               

                                create_common_filters(),
                                
                                # Reinsurance Filters



                                html.Div([
                                    dbc.Row([
                                        dbc.Col([
                                            html.Label("Страховщик:", className="filter-label mb-2"),
                                        ], width=4, className="pe-2"),
                                        dbc.Col([
                                            create_dropdown_component(id='main-insurer', xs=12, sm=12, md=12),   
                                        ], width=8, className="pe-2"),

                                    ], className="g-0 mb-2 align-items-end"),  
                                ], id="main-insurer-section", className="mb-3"),


                                html.Div([
                                    dbc.Row([
                                        dbc.Col([                                            
                                            html.Label("Диаграмма:", className="filter-label mb-2"),
                                        ], width=4, className="pe-2"),
                                        dbc.Col([                                            
                                            create_dropdown_component('primary-chart-type'),
                                        ], width=8, className="pe-2"),

                                    ], className="g-0 mb-2 align-items-end"),                                             
                                ], id="primary-chart-type-section", className="mb-3"),







                                
                                create_comparison_section(),
                                
                                html.Div([
                                    
                                    dbc.Row([
                                        html.Label("По форме перестрахования:", className="filter-label"),
                                        dbc.Col(create_dropdown_component('reinsurance-form-dropdown'), width=12),
                                        html.Label("По типу перестрахования:", className="filter-label"),
                                        dbc.Col(create_dropdown_component('reinsurance-type-dropdown'), width=12),
                                        html.Label("По географии перестрахования:", className="filter-label"),
                                        dbc.Col(create_dropdown_component('reinsurance-geography-dropdown'), width=12),
                                    ], className="g-0 mb-2 align-items-end"),                                     
                                ], id="reinsurance-filters", style={"display": "none"}, className="mb-3"),




                                

                                
                                html.Div([
                                    
                                    dbc.Row([
                                        
                                        # Number of insurers input
                                        dbc.Col([      
                                            html.Label("Кол-во страховщиков:", className="filter-label"),
                                            dcc.Input(
                                                id='number-of-insurers',
                                                type='number',
                                                min=1,
                                                max=100,
                                                step=1,
                                                value=10,
                                                className="form-control",
                                                style={
                                                    "width": "100%",
                                                    "height": "36px",  # Match dropdown height
                                                    "padding": "6px 12px"  # Standard Bootstrap padding
                                                }
                                            ),
                                        ], width=6, className="pe-2"),
                                        
                                        # Number of periods input
                                        dbc.Col([      
                                            html.Label("Кол-во периодов:", className="filter-label"),
                                            dcc.Input(
                                                id='number-of-periods-data-table',
                                                type='number',
                                                min=1,
                                                max=27,
                                                step=1,
                                                value=2,
                                                className="form-control",
                                                style={
                                                    "width": "100%",
                                                    "height": "36px",  # Match dropdown height
                                                    "padding": "6px 12px"  # Standard Bootstrap padding
                                                }
                                            ),
                                        ], width=6, className="pe-2"),
                                        
                                        # dbc.Col([], width=1, className="pe-2"),
                                    ], className="g-0 mb-2 align-items-end"),  
                                    dbc.Row([
        
                                        # Market share and Growth toggles in one line
                                        dbc.Col([
                                            dbc.Row([
                                                # Market Share label and toggle
                                                dbc.Col(
                                                    html.Div([
                                                        html.Label(
                                                            "Доля рынка",
                                                            className="me-2 mb-0",  # Add margin to right, remove bottom margin
                                                            style={
                                                                "display": "inline-block",
                                                                "verticalAlign": "middle",
                                                                 "color": "#333"  # Changed font color to gray
        
                                                            }
                                                        ),
                                                        dbc.Checklist(
                                                            options=[{"label": "", "value": "show"}],
                                                            value=["show"],
                                                            id="toggle-selected-market-share",
                                                            switch=True,
                                                            style={
                                                                "display": "inline-block",
                                                                "verticalAlign": "middle"
                                                            }
                                                        )
                                                    ], style={
                                                        "display": "flex",
                                                        "alignItems": "center",
                                                        "height": "36px"  # Match height with other elements
                                                    }),
                                                    width=7,
                                                    className="pe-2"
                                                ),
                                                
                                                # Growth label and toggle
                                                dbc.Col(
                                                    html.Div([
                                                        html.Label(
                                                            "Динамика",
                                                            className="me-2 mb-0",  # Add margin to right, remove bottom margin
                                                            style={
                                                                "display": "inline-block",
                                                                "verticalAlign": "middle",
                                                                "color": "#333"  # Changed font color to gray
                                                            }
                                                        ),
                                                        dbc.Checklist(
                                                            options=[{"label": "", "value": "show"}],
                                                            value=["show"],
                                                            id="toggle-selected-qtoq",
                                                            switch=True,
                                                            style={
                                                                "display": "inline-block",
                                                                "verticalAlign": "middle"
                                                            }
                                                        )
                                                    ], style={
                                                        "display": "flex",
                                                        "alignItems": "center",
                                                        "height": "36px"  # Match height with other elements
                                                    }),
                                                    width=5
                                                )
                                            ], className="g-0")
                                        ], width=12),
                                    ], className="g-0 mb-2 align-items-end"),  
                                    dbc.Row(
                                        [
                                            dbc.Col(
                                                dbc.Checklist(
                                                    options=[{"label": "", "value": "show"}],
                                                    value=["show"],
                                                    id="toggle-additional-market-share",
                                                    switch=True,
                                                    style={'display': 'none'}
                                                ),
                                                width=6
                                            ),
                                            dbc.Col(
                                                dbc.Checklist(
                                                    options=[{"label": "", "value": "show"}],
                                                    value=["show"],
                                                    id="toggle-additional-qtoq",
                                                    switch=True,
                                                    style={'display': 'none'}
                                                ),
                                                width=6
                                            ),
                                        ],
                                        className="mb-3"
                                    ),                            
                                ], id="data-table-filters", style={"display": "none"}),










                                
                                
                                # Chart type control (hidden for data table)
                                
                                # Insurance-specific filters (shown only for insurance tab)





                                
                                # Comparison section (including secondary chart type)
                                html.Div([

                                    dbc.Row([
                                        dbc.Col([      
                                            dbc.Button(
                                                "Chart Config",
                                                id="toggle-chart-config",
                                                color="secondary",
                                                size="sm",
                                                className="w-100 py-0 ms-1 btn-custom"
                                            ),
                                        ], width=12, className="pe-2"),
    
                                    ], className="g-0 mb-0"),  

                                    
                                ], id="chart-config-button", style={"display": "none"}),
 
                                
                                
                                 
        


                    
                             ]),
                        ]),
                        #dbc.Card([
                        #    dbc.CardBody([  

                        #     ]),
                        #]),








                        
                    ], width=3, className="pe-3"),
                            
                    # Right column - Content
                    dbc.Col([
                        dbc.Card([
                            dbc.CardBody([                           
                                dbc.Row([
                                    dbc.Col([      
                                        html.Div([
                                            html.Label("Тип данных:", className="filter-label mb-2"),  # Add mb-2 for consistent spacing
                                            create_date_type_selector(),
                                        ]),
                                    ], width=4, className="pe-2"),                                    
                                    
                                    dbc.Col([      
                                        html.Div([
                                            html.Label("Период:", className="filter-label mb-2"),  # Add mb-2 for consistent spacing
                                            create_date_range_selector(year_quarter_options, DEFAULT_START_QUARTER, DEFAULT_END_QUARTER, DEFAULT_NUMBER_OF_PERIODS),
                                        ]),
                                    ], width=6, className="pe-2"),
                                  
                                    

 
                                    
                                ], className="g-0 mb-2 align-items-end"), 

                                create_create_chart_buttons_row(),                                       
                                
                                
                                dbc.Row([
                                    html.Div([
                                        
                                        create_chart_container(),
                                    ], id="charts-only-components"),
                                   
                                
                                ], className="g-0 mb-2 align-items-end"), 
                                

                                
                                  

                                
                                
                                

                              
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                dbc.Row([
                                    
                                    html.Div([


                                        


                                    ]),


                                    
                                ], className="g-0 mb-2 align-items-end"), 
                             ]),
                        
                        ]),
                        

                            
                            
                            
                        html.Div([
                            
                            dbc.Card([
                                dbc.CardBody([
                                    html.Div([
                                        html.H5(id='table-title-row1', className="mb-2"),
                                        html.H5(id='table-title-row2', className="mb-2 fw-normal")
                                    ], id='table-title-container', className="mb-3"),

                                    html.Div(
                                        id='data-table',
                                        style={'height': 'calc(100vh - 300px)', 'overflow': 'auto'}
                                    ),

                                    html.Div(
                                        id='processing-error',
                                        className="text-danger mt-3"
                                    )
                                ])
                            ])
                        ], id="data-table-content", style={"display": "none"}),
                    ], width=9),
                ]),

                # Debug section
                dbc.Row([
                    dbc.Col([
                        dbc.Collapse(
                            dbc.Card(dbc.CardBody([
                                html.H4("Debug Logs", className="card-title"),
                                html.Pre(id='debug-output', style={'whiteSpace': 'pre-wrap', 'wordBreak': 'break-all'})
                            ])),
                            id="debug-collapse",
                            is_open=False,
                        ),
                        dbc.Button(
                            "Toggle Debug Logs",
                            id="debug-toggle",
                            className="mb-2 filter-button",
                            color="secondary"
                        )
                    ], width=12)
                ], className="mt-3"),
            ], fluid=True, className="px-4", style={'maxWidth': '2200px'}),
        ], id="app-container")
        
        return layout
    except Exception as e:
        logger.error(f"Error in create_app_layout: {e}")
        return html.Div("An error occurred while creating the layout.")


def setup_tab_state_callbacks(app):
    @app.callback(
        [
            Output("charts-only-components", "style"),
            Output("charts-buttons", "style"),
            Output("chart-config-button", "style"),

            Output("detailize-button-section", "style"),


            
            Output("primary-chart-type-section", "style"),
            Output("premium-loss-checklist-section", "style"),  # Changed from insurance-specific-filters
            Output("main-insurer-section", "style"),  # Changed from insurance-specific-filters
            
            
            Output("reinsurance-filters", "style"),
            Output("comparison-section", "style"),
            Output("comparison-section-wrapper", "style"),
            
            Output("data-table-content", "style"),
            Output("data-table-filters", "style"),

            
            Output("insurance-tab", "className"),
            Output("reinsurance-tab", "className"),
            Output("data-table-tab", "className"),
            Output("show-reinsurance-chart", "data"),
            Output("show-data-table", "data"),
        ],
        [
            Input("insurance-tab", "n_clicks"),
            Input("reinsurance-tab", "n_clicks"),
            Input("data-table-tab", "n_clicks"),
        ],
        [
            
            State("show-reinsurance-chart", "data"),
            State("show-data-table", "data"),
        ]
    )
    @custom_profile
    def toggle_visibility(insurance_clicks, reinsurance_clicks, data_table_clicks, 
                         is_reinsurance, is_data_table):
        ctx = dash.callback_context
        if not ctx.triggered:
            # Initial state
            return (
                {"display": "block"},  # charts-only-components
                {"display": "block"},  # charts-buttons
                {"display": "none"},  # chart-config-button
                {"display": "block"},  # detailize-button-section

                
                {"display": "block"},  # primary-chart-type-section
                {"display": "block"},  # premium-loss-checklist-section
                {"display": "block"},  # main-insurer-section

                
                {"display": "none"},   # reinsurance-filters
                {"display": "block"},  # comparison-section
                {"display": "block"},  # comparison-section-wrapper
                
                {"display": "none"},   # data-table-content
                {"display": "none"},   # data-table-filters
                
                "me-1 tab-like-button active",  # insurance-tab
                "tab-like-button",  # reinsurance-tab
                "tab-like-button",  # data-table-tab
                False,  # show-reinsurance-chart
                False,  # show-data-table
            )
        
        button_id = ctx.triggered[0]["prop_id"].split(".")[0]
        
        if button_id == "data-table-tab":
            return (
                {"display": "none"},    # charts-only-components
                
                {"display": "none"},  # charts-buttons
                {"display": "none"},  # chart-config-button
                {"display": "none"},  # detailize-button-section
                
                {"display": "none"},    # primary-chart-type-section
                {"display": "none"},    # premium-loss-checklist-section
                {"display": "none"},  # main-insurer-section
  
                {"display": "none"},    # reinsurance-filters
                {"display": "none"},    # comparison-section
                {"display": "none"},  # comparison-section-wrapper
                
                {"display": "block"},   # data-table-content
                {"display": "block"},   # data-table-filters
                
                "me-1 tab-like-button",
                "tab-like-button",
                "tab-like-button active",
                False,  # show-reinsurance-chart
                True,   # show-data-table
            )
            
        elif button_id == "insurance-tab":
            return (
                {"display": "block"},  # charts-only-components
                {"display": "block"},  # charts-buttons
                {"display": "none"},  # chart-config-button
                {"display": "block"},  # detailize-button-section
                
                {"display": "block"},  # primary-chart-type-section
                {"display": "block"},  # premium-loss-checklist-section
                {"display": "block"},  # main-insurer-section
              
                {"display": "none"},   # reinsurance-filters
                {"display": "block"},  # comparison-section
                {"display": "block"},  # comparison-section-wrapper
                
                {"display": "none"},   # data-table-content
                {"display": "none"},   # data-table-filters
                
                "me-1 tab-like-button active",
                "tab-like-button",
                "tab-like-button",
                False,  # show-reinsurance-chart
                False,  # show-data-table
            )
            
        elif button_id == "reinsurance-tab":
            return (
                {"display": "block"},  # charts-only-components
                {"display": "block"},  # charts-buttons
                {"display": "none"},  # chart-config-button

                {"display": "block"},  # detailize-button-section
                
                {"display": "block"},  # primary-chart-type-section
                {"display": "none"},   # premium-loss-checklist-section
                {"display": "none"},  # main-insurer-section

                {"display": "block"},  # reinsurance-filters
                {"display": "block"},  # comparison-section
                {"display": "none"},  # comparison-section-wrapper
                
                {"display": "none"},   # data-table-content
                {"display": "none"},   # data-table-filters
                
                "me-1 tab-like-button",
                "tab-like-button active",
                "tab-like-button",
                True,   # show-reinsurance-chart
                False,  # show-data-table
            )
        
        raise PreventUpdate

    @app.callback(
        Output("chart-config-row", "style"),
        Input("toggle-chart-config", "n_clicks"),
        State("chart-config-row", "style"),
        
    )
    @custom_profile
    def toggle_chart_config(n_clicks, current_style):
        if not n_clicks:
            return {"display": "none"}
        
        current_display = current_style.get("display", "none")
        return {"display": "block"} if current_display == "none" else {"display": "none"}
        
        # Modified callback for toggle button
    @app.callback(
        [
            Output("compare-insurers-section", "style"),
            Output("compare-metrics-section", "style"),
            Output("secondary-chart-type-section", "style"),
            Output("comparison-toggle", "active"),
        ],
        [
            Input("comparison-toggle", "n_clicks"),
        ],
        [
            State("comparison-toggle", "active")
        ]
    )
    @custom_profile
    def toggle_comparison_sections(toggle_clicks, is_active):
        ctx = dash.callback_context
        triggered_id = ctx.triggered[0]['prop_id'].split('.')[0]
        
        default_style = {"display": "none"}
        visible_style = {"display": "block"}
        
        # Toggle button clicked
        new_active_state = not is_active if triggered_id == "comparison-toggle" else is_active
                
        if new_active_state:
            return visible_style, visible_style, visible_style, new_active_state
        else:
            return default_style, default_style, default_style, new_active_state


#@custom_profile

def setup_button_callbacks(app):
    @app.callback(
        [Output(id, 'className') for id, _, _ in TOGGLE_BUTTONS],
        [Input(id, 'n_clicks') for id, _, _ in TOGGLE_BUTTONS],
        [State(id, 'className') for id, _, _ in TOGGLE_BUTTONS]
    )
    @custom_profile
    def toggle_all_buttons(*args):
        n_clicks = args[:len(TOGGLE_BUTTONS)]
        current_classes = args[len(TOGGLE_BUTTONS):]
        
        ctx = dash.callback_context
        if not ctx.triggered:
            return ['py-0 toggle-btn toggle-btn-active w-100' if value else 'py-0 toggle-btn w-100' 
                    for _, _, value in TOGGLE_BUTTONS]
        
        button_id = ctx.triggered[0]['prop_id'].split('.')[0]
        
        new_classes = list(current_classes)
        for i, (id, _, _) in enumerate(TOGGLE_BUTTONS):
            if id == button_id:
                new_classes[i] = ('py-0 toggle-btn w-100' 
                                if 'toggle-btn-active' in current_classes[i] 
                                else 'py-0 toggle-btn toggle-btn-active w-100')
        
        return new_classes

    @app.callback(
        [Output(id, 'value') for id, _, _ in TOGGLE_BUTTONS],
        [Input(id, 'className') for id, _, _ in TOGGLE_BUTTONS]
    )
    @custom_profile
    def update_switch_values(*classes):
        return ['active' in cls for cls in classes]

================
File: app/checklist.py
================
import json
import os
import dash
from dash import dcc, html, Input, Output, State, ALL, MATCH
import dash_bootstrap_components as dbc
from dash.exceptions import PreventUpdate
from memory_profiler import profile
import re
import json
import ast
#from checklistutils import load_json, category_structure, handle_parent_child_selections, DEFAULT_CHECKED_CATEGORIES, create_dropdown_component, get_all_descendants

# Set up logger
import logging


from.dropdown import create_dropdown_component
from data_process.data_utils import load_json, category_structure, handle_parent_child_selections, get_all_descendants
from default_values import DEFAULT_CHECKED_CATEGORIES
from logging_config import get_logger, custom_profile
logger = get_logger(__name__)







logger.debug(f"Loaded category structure with {len(category_structure)} top-level categories")

# Default checked categories
logger.debug(f"Default checked categories: {DEFAULT_CHECKED_CATEGORIES}")

class CategoryChecklist:
    def __init__(self, category_structure, selected_categories=None, expanded_categories=None, default_categories=None):
        self.category_structure = category_structure
        logger.debug(f"selected_categories '{selected_categories}'")
        logger.debug(f"default_categories '{default_categories}'")
        logger.debug(f"expanded_categories_received by categorychecklist '{default_categories}'")
        
        # Initialize checked categories
        self.checked_categories = set(selected_categories or [])
        
        # Find parent categories of checked items
        self.parent_categories = self.find_ancestors_for_multiple(self.checked_categories)
        
        # Combine existing expanded categories with parent categories
        expanded_categories = set(expanded_categories or [])
        self.expanded_categories = expanded_categories.union(self.parent_categories)
        
        logger.debug(f"Using categories: {self.checked_categories}")
        logger.debug(f"Parent categories: {self.parent_categories}")
        logger.debug(f"Expanded categories: {self.expanded_categories}")

    def find_ancestors_for_multiple(self, checked_categories):
        def find_ancestors(target):
            ancestors = set()
            current = target
            path = [current]
            while current:
                found = False
                for category, details in self.category_structure.items():
                    if current in details.get('children', []):
                        ancestors.add(category)
                        current = category
                        path.append(current)
                        found = True
                        break
                if not found:
                    current = None
            return ancestors
        
        all_ancestors = set()
        for category in checked_categories:
            category_ancestors = find_ancestors(category)
            all_ancestors.update(category_ancestors)
        
        return all_ancestors

    def create_checklist(self):
        logger.debug("Starting to create checklist")
        components = self._create_category_components(tuple(list(self.category_structure.keys())), 0)
        logger.debug(f"Created {len(components)} top-level components")
        return html.Div(components, id="category-checklist", className="category-checklist")

    def _create_category_components(self, category_codes, level):
        components = []
        for code in category_codes:
            if level == 0 and any(code in cat.get('children', []) for cat in self.category_structure.values()):
                continue
            if level > 4:
                continue
            category = self.category_structure.get(code)
            if not category:
                continue
            component = self._create_category_component(code, category, level)
            components.append(component)
        return components

    def _create_category_component(self, code, category, level):
        is_expanded = code in self.expanded_categories
        is_checked = code in self.checked_categories

        checkbox = dbc.Checkbox(
            id={'type': 'category-checkbox', 'category_code': code},
            label=category['label'],
            value=is_checked,
            className="category-checkbox"
        )

        if category.get('children'):
            expand_button = html.Button(
                "▼" if is_expanded else "▶",
                id={'type': 'category-collapse-button', 'category_code': code},
                className="category-expand-button",
                style={
                    'marginLeft': '5px',
                    'border': 'none',
                    'background': 'none',
                    'padding': '0',
                    'cursor': 'pointer',
                }
            )

            component = html.Div([
                checkbox,
                expand_button
            ], className="category-component d-flex align-items-center")
        else:
            component = checkbox

        if category.get('children'):
            children_components = self._create_category_components(tuple(category['children']), level+1)
            component = html.Div([
                component,
                dbc.Collapse(
                    children_components,
                    id={'type': 'category-collapse', 'category_code': code},
                    is_open=is_expanded
                )
            ])

        return html.Div(
            component,
            className=f"category-level-{level}",
            style={'marginLeft': f'{20 * level}px', 'marginTop': '5px'}
        )






def setup_checklist_callbacks(app: dash.Dash) -> None:
    @app.callback(
        Output('selected-categories-store', 'data'),
        Output('category-dropdown', 'value'),
        
        Input({'type': 'category-checkbox', 'category_code': ALL}, 'value'),
        Input('category-dropdown', 'value'),
        
        Input('detailize-button', 'n_clicks'),
        State({'type': 'category-checkbox', 'category_code': ALL}, 'id'),
        State('selected-categories-store', 'data'),
        prevent_initial_call=True
    )
    @custom_profile    
    def update_store_and_sync_dropdown(checkbox_values, dropdown_value, detailize_clicks, checkbox_ids, current_selected):
        ctx = dash.callback_context
        trigger = ctx.triggered[0]['prop_id'].split('.')[0]
        
        logger.debug(f"update_store_and_sync_dropdown triggered by: {trigger}")
        
        if trigger == 'category-dropdown':
            new_selected = dropdown_value or []
            detailize = False   
        
        elif trigger == 'detailize-button':
            new_selected = current_selected
            detailize = True
        else:  # checkbox trigger
            new_selected = [
                id_dict['category_code'] for value, id_dict in zip(checkbox_values, checkbox_ids)
                if value and id_dict['category_code'] in category_structure
            ]
            detailize = False
        
        new_selected = handle_parent_child_selections(new_selected, category_structure, detailize)
        
        logger.debug(f"Final new selected categories: {new_selected}")
        return new_selected, new_selected


    @app.callback(
        Output('expanded-categories-store', 'data'),
        Input({'type': 'category-collapse-button', 'category_code': ALL}, 'n_clicks'),
        Input('selected-categories-store', 'data'),  # Add this input
        State({'type': 'category-collapse-button', 'category_code': ALL}, 'id'),
        State('expanded-categories-store', 'data'),
        prevent_initial_call=True
    )
    def update_expanded_categories(n_clicks_list, selected_categories, button_ids, expanded_categories):
        ctx = dash.callback_context
        if not ctx.triggered:
            raise PreventUpdate
            
        trigger = ctx.triggered[0]['prop_id']
        
        # Initialize expanded categories
        if expanded_categories is None:
            expanded_categories = []
        expanded_categories = set(expanded_categories)
        
        # If triggered by selection change, add parent categories
        if 'selected-categories-store' in trigger:
            checklist = CategoryChecklist(category_structure, selected_categories=selected_categories)
            parent_categories = checklist.parent_categories
            expanded_categories.update(parent_categories)
        else:
            # Handle manual expansion/collapse
            match = re.search(r'"category_code":"([^"]*)"', trigger)
            if match:
                category_code = match.group(1)
                if category_code in expanded_categories:
                    expanded_categories.remove(category_code)
                else:
                    expanded_categories.add(category_code)
        
        logger.debug(f"Updated expanded categories: {expanded_categories}")
        return list(expanded_categories)
    
    @app.callback(
        Output({'type': 'category-collapse', 'category_code': MATCH}, 'is_open'),
        Output({'type': 'category-collapse-button', 'category_code': MATCH}, 'children'),
        Input({'type': 'category-collapse-button', 'category_code': MATCH}, 'n_clicks'),
        State({'type': 'category-collapse', 'category_code': MATCH}, 'is_open'),
    )
    @custom_profile    
    def toggle_category_collapse(n_clicks, is_open):
        if not n_clicks:
            raise PreventUpdate
    
        ctx = dash.callback_context
        logger.warning(f"toggle_category_collapse ctx: {ctx}")
    
        if not ctx.triggered:
            raise PreventUpdate
    
        triggered_id = ctx.triggered[0]['prop_id']
        logger.warning(f"Full triggered_id: {triggered_id}")
    
        # Use regex to extract the entire category_code, including any dots
        match = re.search(r'"category_code":"([^"]*)"', triggered_id)
        if match:
            category_code = match.group(1)
            logger.warning(f"Extracted category_code: {category_code}")
        else:
            logger.error(f"Failed to extract category_code from: {triggered_id}")
            category_code = "Unknown"
    
        new_is_open = not is_open
        new_button_text = "▼" if new_is_open else "▶"
        
        logger.warning(f"Category: {category_code}")
        logger.warning(f"new_is_open: {new_is_open}")
        logger.warning(f"new_button_text: {new_button_text}")
        
        return new_is_open, new_button_text
        
        
    @app.callback(
        Output("category-collapse", "children"),
        Output("category-collapse", "is_open"),
        Output("toggle-all-categories", "children"),
        Input("toggle-all-categories", "n_clicks"),
        Input('selected-categories-store', 'data'),
        Input('expanded-categories-store', 'data'),
        State("category-collapse", "is_open"),
    )
    @custom_profile    
    def update_category_checklist(n_clicks, selected_categories, expanded_categories, is_open):
        ctx = dash.callback_context
        if not ctx.triggered:
            # Initial load
            return None, False, "Полный перечень"
        
        trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]
        
        logger.debug(f"update_category_checklist triggered by: {trigger_id}")
        
        if trigger_id == "toggle-all-categories":
            new_is_open = not is_open
            new_button_text = "Скрыть" if new_is_open else "Полный перечень"
        else:
            new_is_open = is_open
            new_button_text = "Скрыть" if is_open else "Полный перечень"
        
        checklist = CategoryChecklist(category_structure, selected_categories=selected_categories, expanded_categories=expanded_categories)
        return checklist.create_checklist(), new_is_open, new_button_text
     

def create_stores_row():
    return dbc.Row([
        dcc.Store(id='selected-categories-store', data=DEFAULT_CHECKED_CATEGORIES),
        dcc.Store(id='expanded-categories-store', data=[]),
        dcc.Store(id='all-categories-expanded', data=False),
        
        html.Div(id="dummy-output"),
    ], className="p-0 mb-0")


def create_checklist_row():
    checklist = CategoryChecklist(category_structure, selected_categories=DEFAULT_CHECKED_CATEGORIES)
    
    return dbc.Row([
        dbc.Collapse(
            checklist.create_checklist(),
            id="category-collapse",
            is_open=True
        )        
    ], className="p-0 mb-0")

checklist_stores_row = create_stores_row()                  

def create_checklist_layout():
    logger.debug("Creating app layout")
    
    layout = dbc.Container([
        create_dropdown_component(id='category-dropdown', xs=12, sm=12, md=12),
        dbc.Button("Полный перечень чеклист", id='toggle-all-categories', color="secondary", n_clicks=0, className="simple-button"),
        dbc.Button("Drill down", id="detailize-button", color="secondary", className="simple-button"),      
        create_stores_row(),
        create_checklist_row(),        

    ], fluid=True)
    
    logger.debug("App layout created")
    return layout
       


def create_dash_app():
    logger.debug("Creating Dash app")
    app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP], suppress_callback_exceptions=True)
    app.layout = create_checklist_layout()
    setup_checklist_callbacks(app)
    return app


if __name__ == '__main__':
    logger.debug("Starting the Dash app")
    app = create_dash_app()
    app.run_server(debug=True)
    logger.debug("Dash app server started")

================
File: app/date_range_filter.py
================
from dash import html, dcc, Input, Output, State, ALL, MATCH
import dash_bootstrap_components as dbc
import dash
import logging
from default_values import DEFAULT_PERIOD_TYPE, DEFAULT_Q_VALUE, DEFAULT_AGGREGATION_TYPE
from constants.filter_options import *
from default_values import *
from datetime import datetime
# Set up logging
from logging_config import get_logger, custom_profile
logger = logging.getLogger(__name__)






def create_date_type_selector():
    return dbc.Row([
        html.Div([
            html.Div([
                dbc.ButtonGroup([
                    dbc.Button(
                        "YTD", 
                        id={"type": "main-btn", "index": "ytd"}, 
                        size="sm",
                        className="py-0 btn-custom",
                        style={"height": "36px"}
                    ),
                    dbc.Button(
                        "YoY", 
                        id={"type": "main-btn", "index": "yoy"}, 
                        size="sm",
                        className="py-0 ms-1 btn-custom",
                        style={"height": "36px"}
                    ),
                    dbc.Button(
                        "QoQ", 
                        id={"type": "main-btn", "index": "qoq"}, 
                        size="sm",
                        className="py-0 ms-1 btn-custom",
                        style={"height": "36px"}
                    ),
                    dbc.Button(
                        "MAT", 
                        id={"type": "main-btn", "index": "mat"}, 
                        size="sm",
                        className="py-0 ms-1 btn-custom",
                        style={"height": "36px"}
                    ),
                    dbc.Button(
                        "Cum", 
                        id={"type": "main-btn", "index": "cum"}, 
                        size="sm",
                        className="py-0 ms-1 btn-custom",
                        style={"height": "36px"}
                    ),
                ]),
                dbc.Collapse(
                    dbc.ButtonGroup(id="additional-options"),
                    id="collapse",
                    is_open=True,
                    className="d-inline-block ms-1"
                )
            ], className="d-flex align-items-center"),
            dcc.Store(id='date-type-state', data=DEFAULT_PERIOD_TYPE),
            html.Div(id="date-type-output", style={'display': 'inline-block', 'marginRight': '10px'}),
            dcc.Store(id='period-type', data=DEFAULT_AGGREGATION_TYPE),
            dcc.Store(id='quarter-value-output', data=DEFAULT_Q_VALUE)
            
        ], className="p-0")
    ], align="center")

def load_initial_state():
    initial_state = DEFAULT_PERIOD_TYPE
    return generate_outputs(initial_state)

def generate_outputs(state):
    if state['main'] in ["ytd", "yoy"]:
        is_open = True
        additional_options = [
            dbc.Button(
                "3M", 
                id={"type": "sub-btn", "index": "3m"}, 
                size="sm", 
                className="py-0 ms-1 btn-secondary-custom",
                style={"height": "36px"}
            ),
            dbc.Button(
                "1H", 
                id={"type": "sub-btn", "index": "1h"}, 
                size="sm", 
                className="py-0 ms-1 btn-secondary-custom",
                style={"height": "36px"}
            ),
            dbc.Button(
                "9M", 
                id={"type": "sub-btn", "index": "9m"}, 
                size="sm", 
                className="py-0 ms-1 btn-secondary-custom",
                style={"height": "36px"}
            ),
            dbc.Button(
                "FY", 
                id={"type": "sub-btn", "index": "fy"}, 
                size="sm",
                className="py-0 ms-1 btn-secondary-custom",
                style={"height": "36px"}
            ),
        ] if state['main'] == "ytd" else [
            dbc.Button(
                "Q", 
                id={"type": "sub-btn", "index": "q"}, 
                size="sm", 
                className="py-0 ms-1 btn-secondary-custom",
                style={"height": "36px"}
            ),
            dbc.Button(
                "Y", 
                id={"type": "sub-btn", "index": "y"}, 
                size="sm",
                className="py-0 ms-1 btn-secondary-custom",
                style={"height": "36px"}
            ),
        ]
        
        # Set active class for selected sub-button
        if state['sub']:
            for btn in additional_options:
                if btn.id['index'] == state['sub']:
                    btn.className = btn.className + " active"
    else:
        is_open = False
        additional_options = []

    # Set button classes instead of colors
    main_classes = [
        f"py-0 btn-custom{' active' if i == state['main'] else ''}" 
        for i in ["ytd", "yoy", "qoq", "mat", "cum"]
    ]

    output_text = ""
    period_type, quarter_value = get_period_type_and_quarter(state['main'], state['sub'])

    return state, is_open, additional_options, main_classes, output_text, period_type, quarter_value


def get_period_type_and_quarter(main, sub):
    if main == 'ytd':
        period_type = 'same_q_last_year_ytd'
        quarter_value = {'3m': 1, '1h': 2, '9m': 3, 'fy': 4}.get(sub, 2)  # Default to 2 if sub is None
    elif main == 'yoy':
        if sub == 'q':
            period_type = 'same_q_last_year'
            quarter_value = 1
        elif sub == 'y':
            period_type = 'same_q_last_year_mat'
            quarter_value = 4
        else:
            period_type =  'same_q_last_year'  # Default if sub is None
            quarter_value = 1
    elif main == 'qoq':
        period_type = 'previous_quarter'
        quarter_value = 4    
    
    elif main == 'mat':
        period_type = 'previous_q_mat'
        quarter_value = 4
    elif main == 'cum':
        period_type = 'cumulative_sum'
        quarter_value = 4
    else:
        period_type = 'previous_quarter'  # Default
        quarter_value = 4  # Default

    return period_type, quarter_value



def create_date_range_selector(year_quarter_options, DEFAULT_START_QUARTER, DEFAULT_END_QUARTER, DEFAULT_NUMBER_OF_PERIODS):
    return dbc.Row([
        dbc.Col([
            html.Div([
                dbc.ButtonGroup([
                    dbc.Button(
                        "1Y", 
                        id="btn-1y", 
                        n_clicks=0, 
                        size="sm",
                        className="py-0 btn-custom",
                        style={"height": "36px"}
                    ),
                    dbc.Button(
                        "2Y", 
                        id="btn-2y", 
                        n_clicks=0, 
                        size="sm",
                        className="py-0 ms-1 btn-custom",
                        style={"height": "36px"}
                    ),
                    dbc.Button(
                        "5Y", 
                        id="btn-5y", 
                        n_clicks=0, 
                        size="sm",
                        className="py-0 ms-1 btn-custom",
                        style={"height": "36px"}
                    ),
                    dbc.Button(
                        "Custom", 
                        id="btn-custom", 
                        n_clicks=0, 
                        size="sm",
                        className="py-0 ms-1 btn-custom",
                        style={"height": "36px"}
                    ),
                ]),
                dbc.Collapse([
                    html.Div([
                        html.Div([
                            dbc.Input(
                                id="custom-year-input",
                                type="number",
                                style={
                                    "width": 75,
                                    "height": "36px"
                                },
                                className="filter-dropdown py-0"
                            ),
                        ], style={
                            "display": "inline-block",
                            "verticalAlign": "middle",
                            "marginRight": "4px"
                        }),
                        
                        html.Div([
                            dcc.Dropdown(
                                id='start-quarter',
                                options=year_quarter_options,
                                value=DEFAULT_START_QUARTER,
                                clearable=False,
                                className="filter-dropdown",
                                style={
                                    "width": 100,
                                    "height": "36px"
                                }
                            ),
                        ], style={
                            "display": "inline-block",
                            "verticalAlign": "middle",
                            "marginRight": "4px"
                        }),
                        
                        html.Div([
                            dcc.Dropdown(
                                id='end-quarter',
                                options=year_quarter_options,
                                value=DEFAULT_END_QUARTER,
                                clearable=False,
                                className="filter-dropdown",
                                style={
                                    "width": 100,
                                    "height": "36px"
                                }
                            ),
                        ], style={
                            "display": "inline-block",
                            "verticalAlign": "middle",
                            "marginRight": "4px"
                        }),
                        
                        html.Div([
                            dbc.Button(
                                "Go",
                                id="btn-custom-year",
                                className="py-0 btn-custom",
                                style={"height": "36px"}
                            ),
                        ], style={
                            "display": "inline-block",
                            "verticalAlign": "middle"
                        }),
                    ], className="d-flex align-items-center")
                ], 
                id="custom-range-collapse",
                is_open=False,
                className="horizontal-collapse-container ms-1"),
                dcc.Store(id='hidden-periods', data=0),
                # Store the options in a hidden div
                dcc.Store(id='quarter-options-store', data=year_quarter_options)
            ], className="d-flex align-items-center")
        ], width=12, className="p-0"),
                
        # Hidden elements
        dbc.Col([
            html.Div([
                dcc.Dropdown(
                    id='number-of-years-to-show',
                    options=[{'label': str(i), 'value': i} for i in range(1, 27)],
                    value=DEFAULT_NUMBER_OF_PERIODS,
                    clearable=False,
                    style={'display': 'none', 'width': '100px', "height": "36px"}
                ),
            html.Div("\u00A0", style={'display': 'inline-block', 'marginRight': '10px'}),
            ], className="d-flex align-items-center justify-content-end")
        ], width=12, className="d-flex align-items-center")
    ], align="center")

def setup_layout_callbacks(app):
    @app.callback(
        Output("number-of-years-to-show", "value"),
        Output("btn-1y", "className"),
        Output("btn-2y", "className"),
        Output("btn-5y", "className"),
        Output("btn-custom", "className"),
        Output("custom-range-collapse", "is_open"),
        Output("start-quarter", "value"),
        Output("end-quarter", "value"),
        Output("custom-year-input", "value"),
        [Input("btn-1y", "n_clicks"),
         Input("btn-2y", "n_clicks"),
         Input("btn-5y", "n_clicks"),
         Input("btn-custom", "n_clicks"),
         Input("btn-custom-year", "n_clicks")],
        [State("custom-year-input", "value"),
         State("number-of-years-to-show", "value"),
         State("custom-range-collapse", "is_open"),
         State("start-quarter", "value"),
         State("end-quarter", "value"),
         State("btn-1y", "className"),
         State("btn-2y", "className"),
         State("btn-5y", "className"),
         State("btn-custom", "className"),
         State("quarter-options-store", "data")]  # Add this State
    )
    @custom_profile
    def update_periods_classes_and_collapse(btn1, btn2, btn5, btn_custom, btn_custom_year, 
                                         custom_year, current_periods, is_open, 
                                         start_quarter, end_quarter, class_1y, class_2y, class_5y, class_custom,
                                         year_quarter_options):  # Add this parameter
        ctx = dash.callback_context
        if not ctx.triggered:
            initial_classes = ["py-0 btn-custom"] * 4
            initial_classes[DEFAULT_BUTTON_INDEX] = "py-0 btn-custom active"
            return DEFAULT_NUMBER_OF_PERIODS, *initial_classes, False, start_quarter, end_quarter, None

        button_id = ctx.triggered[0]['prop_id'].split('.')[0]
        periods = current_periods
        classes = ["py-0 btn-custom"] * 4

        # Get available quarters from options
        available_quarters = [opt['value'] for opt in year_quarter_options]
        available_quarters.sort()  # Ensure quarters are in chronological order
        
        def calculate_quarters(num_years):
            # Get current date to calculate target quarters
            current_date = datetime.now()
            current_year = current_date.year
            current_quarter = (current_date.month - 1) // 3 + 1
            target_end = f"{current_year}Q{current_quarter}"
            
            # Find the actual end quarter (latest available if current quarter not available)
            end_quarter = available_quarters[-1]  # Default to latest available
            for q in reversed(available_quarters):
                if q <= target_end:
                    end_quarter = q
                    break
            
            # Calculate target start quarter
            end_year = int(end_quarter.split('Q')[0])
            target_start_year = end_year - num_years
            target_start = f"{target_start_year}Q{end_quarter[-1]}"
            
            # Find the actual start quarter (earliest available if target not available)
            start_quarter = available_quarters[0]  # Default to earliest available
            for q in available_quarters:
                if q >= target_start:
                    start_quarter = q
                    break
            
            return start_quarter, end_quarter

        if button_id == "btn-custom":
            is_open = not is_open
            classes = [class_1y, class_2y, class_5y, class_custom]
            return periods, *classes, is_open, start_quarter, end_quarter, custom_year

        elif button_id == "btn-1y":
            periods = 1
            classes[0] = "py-0 btn-custom active"
            is_open = False
            start_quarter, end_quarter = calculate_quarters(1)
        
        elif button_id == "btn-2y":
            periods = 2
            classes[1] = "py-0 btn-custom active"
            is_open = False
            start_quarter, end_quarter = calculate_quarters(2)
            
        elif button_id == "btn-5y":
            periods = 5
            classes[2] = "py-0 btn-custom active"
            is_open = False
            start_quarter, end_quarter = calculate_quarters(5)
        
        elif button_id == "btn-custom-year" and custom_year:
            periods = int(custom_year)
            classes[3] = "py-0 btn-custom active"
            is_open = is_open
            start_quarter, end_quarter = calculate_quarters(periods)
        else:
            classes[3] = "py-0 btn-custom active" if is_open else "py-0 btn-custom"

        return periods, *classes, is_open, start_quarter, end_quarter, custom_year

    @app.callback(
        Output({"type": "sub-btn", "index": MATCH}, "className"),
        Input({"type": "sub-btn", "index": MATCH}, "n_clicks"),
        State('date-type-state', 'data'),
    )
    @custom_profile    
    def update_sub_button_class(n_clicks, current_state):
        if not n_clicks:
            raise dash.exceptions.PreventUpdate
        
        ctx = dash.callback_context
        button_index = eval(ctx.triggered[0]["prop_id"].split(".")[0])["index"]
        return "py-0 ms-1 btn-secondary-custom active" if button_index == current_state['sub'] else "py-0 ms-1 btn-secondary-custom"

    # Rest of get_period_type_and_quarter and other functions remain the same

    @app.callback(
        Output('date-type-state', 'data'),
        Output("collapse", "is_open"),
        Output("additional-options", "children"),
        Output({"type": "main-btn", "index": ALL}, "color"),
        Output("date-type-output", "children"),
        Output('period-type', 'data'),
        Output('quarter-value-output', 'data'),
        Input({"type": "main-btn", "index": ALL}, "n_clicks"),
        Input({"type": "sub-btn", "index": ALL}, "n_clicks"),
        State('date-type-state', 'data'),
    )
    @custom_profile
    def update_date_type_state(main_clicks, sub_clicks, current_state):
        ctx = dash.callback_context
        if not ctx.triggered:
            # Initial load
            logger.info("Initial state loaded")
            return load_initial_state()
        
        button_id = ctx.triggered[0]["prop_id"].split(".")[0]
        button_type, button_index = eval(button_id)["type"], eval(button_id)["index"]
        logger.info(f"Button clicked: {button_type} - {button_index}")

        new_state = current_state.copy()
        if button_type == "main-btn":
            new_state['main'] = button_index
            new_state['sub'] = None
        elif button_type == "sub-btn":
            new_state['sub'] = button_index

        logger.info(f"Current State - Main: {new_state['main'].upper()}, Sub: {new_state['sub'].upper() if new_state['sub'] else 'None'}")

        return generate_outputs(new_state)

    @app.callback(
        Output({"type": "sub-btn", "index": MATCH}, "color"),
        Input({"type": "sub-btn", "index": MATCH}, "n_clicks"),
        State('date-type-state', 'data'),
    )
    @custom_profile
    def update_sub_button_color(n_clicks, current_state):
        if not n_clicks:
            raise dash.exceptions.PreventUpdate
        
        ctx = dash.callback_context
        button_index = eval(ctx.triggered[0]["prop_id"].split(".")[0])["index"]
        return "success" if button_index == current_state['sub'] else "primary"

================
File: app/dropdown.py
================
from constants.filter_options import *

from constants.translations import translate
import dash_bootstrap_components as dbc
from dash import dcc
from dash import html
from data_process.data_utils import default_insurer_options, category_structure, default_benchmark_options, get_top_level_and_children, get_all_descendants, get_categories_by_level
from default_values import DEFAULT_PRIMARY_METRICS, DEFAULT_SECONDARY_METRICS, DEFAULT_INSURER, DEFAULT_COMPARE_INSURER, DEFAULT_X_COL_INSURANCE, DEFAULT_SERIES_COL_INSURANCE, DEFAULT_GROUP_COL_INSURANCE, DEFAULT_COMPARE_BENCHMARK, DEFAULT_CHART_TYPE, DEFAULT_SECONDARY_CHART_TYPE, DEFAULT_CHECKED_CATEGORIES, DEFAULT_TABLE_METRIC, DEFAULT_ADDITIONAL_TABLE_METRIC




#        'options': get_top_level_and_children(category_structure),  



# Use the function to get the options


# Dictionary mapping dropdown IDs to their configurations
DROPDOWN_CONFIG = {
    'category-dropdown': {
        'label': False,
        'options': get_categories_by_level(category_structure, level=3), 
        'value': DEFAULT_CHECKED_CATEGORIES,
        'multi': True,
        'placeholder': "Select categories..."
    },

    'primary-y-metric': {
        'label': False,
        'options': ALL_METRICS_OPTIONS_Y,
        'value': DEFAULT_PRIMARY_METRICS,
        'multi': True,
        'placeholder': "Select primary metric"
    },



    
    'table-selected-metric': {
        'label':  False,
        'options': MAIN_METRICS_OPTIONS_TABLE,
        'value': ['total_premiums'],
        'multi': True,
        'placeholder': "Select..."
    },
    'table-additional-metric': {
        'label':  False,
        'options': ADDITIONAL_METRICS_OPTIONS_TABLE,
        'value': DEFAULT_ADDITIONAL_TABLE_METRIC,
        'multi': True,
        'placeholder': "Компания"
    },

    
    'secondary-y-metric': {
        'label': "",
        'options': ALL_METRICS_OPTIONS,
        'value': DEFAULT_SECONDARY_METRICS,
        'multi': True,
        'placeholder': "Показатель"
    },
    'main-insurer': {
        'label': False,
        'options': default_insurer_options,
        'value': DEFAULT_INSURER,
        'multi': False,
        'clearable': False
    },


    
    'compare-insurers-main': {
        'label': False,
        'options': default_insurer_options,
        'value': DEFAULT_COMPARE_INSURER,
        'multi': True,
        'placeholder': "Компания"
    },
    'compare-to-benchmark': {
        'label': False,
        'options': default_benchmark_options,
        'value': DEFAULT_COMPARE_BENCHMARK,
        'multi': True,
        'placeholder': "Select Benchmark"
    },

    'reinsurance-form-dropdown': {
        'label': False,
        'options': REINSURANCE_FORM_DROPDOWN_OPTIONS,
        'value': None,
        'multi': True,
        'placeholder': "Select to Compare"

    },
    'reinsurance-type-dropdown': {
        'label': False,
        'options': REINSURANCE_TYPE_DROPDOWN_OPTIONS,
        'value': None,
        'multi': True,       
        'placeholder': "Reinsurance Type"

    },
    'reinsurance-geography-dropdown': {
        'label': False,
        'options': REINSURANCE_GEOGRAPHY_DROPDOWN_OPTIONS,
        'value': None,
        'multi': True,      
        'placeholder': "Reinsurance Geography"
    },        

        
    'table-additional-metric': {
        'label': "Показатель",
        'options': [],
        'value': None,
        'multi': True,
        'placeholder': "Select"

    },

    'x-column': {
        'label': False,
        'options': INSURANCE_COLUMN_SWITCH_OPTIONS,
        'value': DEFAULT_X_COL_INSURANCE,
        'clearable': True,
        'placeholder': "x_axis",

    },
    'series-column': {       
        'label': False,
        
        'options': INSURANCE_COLUMN_SWITCH_OPTIONS,
        'value': DEFAULT_SERIES_COL_INSURANCE,
        'clearable': True,
        'placeholder': "series",

    },
    'group-column': {
        'label': False,
        
        'options': INSURANCE_COLUMN_SWITCH_OPTIONS,
        'value': DEFAULT_GROUP_COL_INSURANCE,
        'clearable': True,
        'placeholder': "groups",
    },

    
    'primary-chart-type': {
        'label': False,
        'options': CHART_TYPE_DROPDOWN_OPTIONS,
        'clearable': False,

        'value': DEFAULT_CHART_TYPE,
        'placeholder': "Select chart type",

    },



    
    'secondary-chart-type': {
        'label': False,
        'options': CHART_TYPE_DROPDOWN_OPTIONS,
        'clearable': False,

        'value': DEFAULT_SECONDARY_CHART_TYPE,
        'placeholder': "Select chart type",

    }
}


def create_dropdown_component(id, options=None, xs=12, sm=12, md=12):
    if id not in DROPDOWN_CONFIG:
        raise ValueError(f"No configuration found for dropdown id: {id}")
    
    config = DROPDOWN_CONFIG[id]
    return dbc.Col([
        html.Label(translate(config.get('label', '')), className="filter-label"),
        
        dcc.Dropdown(
            id=id,
            options=config['options'],
            value=config['value'],
            multi=config.get('multi', False),
            placeholder=translate(config.get('placeholder', '')),
            clearable=config.get('clearable', True),
            className="filter-dropdown"
        )
    ], xs=xs, sm=sm, md=md, className="p-0")

================
File: app/filter_values_callbacks.py
================
import dash
from dash import html, dcc, Input, Output, State, ALL, MATCH, dash_table, html, clientside_callback
import pandas as pd
from dash.exceptions import PreventUpdate
from dash.dash_table.Format import Format, Scheme, Symbol
import dash_bootstrap_components as dbc
from default_values import (
    DEFAULT_PREMIUM_LOSS_TYPES, 
    DEFAULT_INSURER, DEFAULT_PRIMARY_METRICS, DEFAULT_SECONDARY_METRICS, 
    DEFAULT_TABLE_METRIC, DEFAULT_EXPANDED_CATEGORIES, DEFAULT_CHART_TYPE, DEFAULT_SECONDARY_CHART_TYPE,
    DEFAULT_X_COL_INSURANCE, DEFAULT_SERIES_COL_INSURANCE, DEFAULT_GROUP_COL_INSURANCE, 
    DEFAULT_CHECKED_CATEGORIES, DEFAULT_AGGREGATION_TYPE, DEFAULT_COMPARE_INSURER,
    DEFAULT_INSURER_REINSURANCE, DEFAULT_PRIMARY_METRICS_REINSURANCE, DEFAULT_SECONDARY_METRICS_REINSURANCE, 
    DEFAULT_COMPARE_INSURER_REINSURANCE, DEFAULT_PREMIUM_LOSS_TYPES_REINSURANCE, DEFAULT_PREMIUM_LOSS_TYPES,
    DEFAULT_X_COL_REINSURANCE, DEFAULT_SERIES_COL_REINSURANCE, DEFAULT_GROUP_COL_REINSURANCE,
    DEFAULT_INSURER_TABLE, DEFAULT_COMPARE_INSURER_TABLE, DEFAULT_PRIMARY_METRICS_TABLE, 
    DEFAULT_PRIMARY_METRICS_TABLE, DEFAULT_SECONDARY_METRICS_TABLE, DEFAULT_X_COL_TABLE,
    DEFAULT_SERIES_COL_TABLE, DEFAULT_GROUP_COL_TABLE, DEFAULT_PREMIUM_LOSS_TYPES_TABLE,
    DEFAULT_PRIMARY_METRICS_INWARD, DEFAULT_SECONDARY_METRICS_INWARD


) 
from logging_config import get_logger, custom_profile


import logging
from logging_config import get_logger
logger = get_logger(__name__)

#@custom_profile
def setup_filter_values_callbacks(app):
    @app.callback(
        [Output('x-column', 'value'),
         Output('series-column', 'value'),
         Output('group-column', 'value'),
         Output('main-insurer', 'value'),
         Output('compare-insurers-main', 'value'),
         Output('primary-y-metric', 'value'),
         Output('secondary-y-metric', 'value'),
         Output('premium-loss-checklist', 'value'),

         
        
        ],
        [Input('show-reinsurance-chart', 'data'),
         Input('selected-categories-store', 'data'),
         Input('compare-insurers-main', 'value'),
         Input('secondary-y-metric', 'value'),    
         Input('x-column', 'value'),
         Input('series-column', 'value'),
         Input('group-column', 'value'),
         Input('premium-loss-checklist', 'value'),


         
        ],
        [State('x-column', 'value'),
         State('series-column', 'value'),
         State('group-column', 'value'),
         State('main-insurer', 'value'),
         State('compare-insurers-main', 'value'),
         State('primary-y-metric', 'value'),
         State('secondary-y-metric', 'value'),
         State('show-data-table', 'data')

        
        
        ]
    )
    @custom_profile
    def update_filter_values(show_reinsurance_chart, selected_linemains, compare_insurers, secondary_y_metric, x_column, series_column, group_column, premium_loss_selection, x_column_state, series_column_state, group_column_state, main_insurer_state, compare_insurers_state, primary_y_metric_state, secondary_y_metric_state, show_data_table):
        """
        Update column values when switching between insurance and reinsurance tabs
        """
        ctx = dash.callback_context
        if not ctx.triggered:
            raise PreventUpdate

        default_returns = {
            'x_column': dash.no_update,
            'series_column': dash.no_update,
            'group_column': dash.no_update,
            'main_insurer': dash.no_update,
            'compare_insurers': dash.no_update,
            'primary_y_metric': dash.no_update,
            'secondary_y_metric': dash.no_update,
            'premium_loss_selection': dash.no_update,
            

        }

        
        trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]
        logger.info(f"trigger_id {trigger_id}")    
        
        logger.info(f"group_column_state {group_column_state}")    
        chart_columns = [x_column, series_column, group_column]

        if trigger_id in ['compare-insurers-main', 'selected-categories-store', 'secondary-y-metric']:
           
            if trigger_id == 'compare-insurers-main':
                group_column = 'insurer' if 'insurer' not in chart_columns else dash.no_update
                compare_insurers = compare_insurers
                secondary_y_metric = dash.no_update
                
    
            elif trigger_id == 'selected-categories-store':
                compare_insurers = dash.no_update
                secondary_y_metric = dash.no_update              
                
                if len(selected_linemains) > 1:
                    group_column = 'linemain' if 'linemain' not in chart_columns else dash.no_update
    
                else:
                    raise PreventUpdate
    
            
            elif trigger_id == 'secondary-y-metric':
                group_column = 'metric' if 'metric' not in chart_columns else dash.no_update
                #x_column = dash.no_update
                #series_column = dash.no_update
                compare_insurers = dash.no_update
                secondary_y_metric = secondary_y_metric



            default_returns.update({
                'group_column': group_column,                
                'series_column': dash.no_update, #group_column_state if group_column_state != group_column else series_column_state,
                'x_column': dash.no_update, #_state if x_column_state != series_column else series_column_state if series_column_state != group_column else group_column_state,
                'compare_insurers': compare_insurers,
                'secondary_y_metric': secondary_y_metric
            
            })  

        elif trigger_id in ['x-column', 'series-column', 'group-column']:
        
            if trigger_id == 'x-column':
                logger.warning(f"x_column_state {x_column_state}")    
                logger.warning(f"x_column {x_column}")    
                
                x_column = x_column
                series_column = series_column_state if series_column_state != x_column else DEFAULT_SERIES_COL_INSURANCE if DEFAULT_SERIES_COL_INSURANCE != x_column else DEFAULT_X_COL_INSURANCE
                group_column = group_column_state if group_column_state != x_column and group_column_state != series_column else DEFAULT_GROUP_COL_INSURANCE if DEFAULT_GROUP_COL_INSURANCE != x_column and DEFAULT_GROUP_COL_INSURANCE != series_column else DEFAULT_X_COL_INSURANCE if DEFAULT_X_COL_INSURANCE != series_column and DEFAULT_X_COL_INSURANCE != x_column else DEFAULT_SERIES_COL_INSURANCE

            if trigger_id == 'series-column':
                series_column = series_column
                x_column = x_column_state if x_column_state != series_column else DEFAULT_X_COL_INSURANCE if DEFAULT_X_COL_INSURANCE != series_column else DEFAULT_SERIES_COL_INSURANCE
                group_column = group_column_state if group_column_state != series_column and group_column_state != x_column else DEFAULT_GROUP_COL_INSURANCE if DEFAULT_GROUP_COL_INSURANCE != series_column and DEFAULT_GROUP_COL_INSURANCE != x_column else DEFAULT_SERIES_COL_INSURANCE if DEFAULT_SERIES_COL_INSURANCE != series_column and DEFAULT_SERIES_COL_INSURANCE != x_column else DEFAULT_X_COL_INSURANCE

            if trigger_id == 'group-column':
                group_column = group_column
                x_column = x_column_state if x_column_state != group_column else DEFAULT_X_COL_INSURANCE if DEFAULT_X_COL_INSURANCE != group_column else DEFAULT_GROUP_COL_INSURANCE
                series_column = series_column_state if series_column_state != group_column and series_column_state != x_column else DEFAULT_SERIES_COL_INSURANCE if DEFAULT_SERIES_COL_INSURANCE != group_column and DEFAULT_SERIES_COL_INSURANCE != x_column else DEFAULT_GROUP_COL_INSURANCE if DEFAULT_GROUP_COL_INSURANCE != x_column and DEFAULT_GROUP_COL_INSURANCE != group_column else DEFAULT_X_COL_INSURANCE
        
            default_returns.update({
                'x_column':x_column,              
                'series_column': series_column,
                'group_column': group_column               
            
            })  
       
        elif trigger_id == 'premium-loss-checklist':
            logger.warning(f"premium_loss_selection {premium_loss_selection}")    
            if 'direct' in premium_loss_selection:
                primary_y_metric = DEFAULT_PRIMARY_METRICS
                secondary_y_metric = DEFAULT_SECONDARY_METRICS
            else:
                primary_y_metric = DEFAULT_PRIMARY_METRICS_INWARD
                secondary_y_metric = DEFAULT_SECONDARY_METRICS_INWARD
            
            default_returns.update({
                'primary_y_metric': primary_y_metric,              
                'secondary_y_metric': secondary_y_metric  
            
            })             

        
        elif trigger_id == 'show-reinsurance-chart':

            if show_reinsurance_chart:
                default_returns.update({
                    'x_column': DEFAULT_X_COL_REINSURANCE,
                    'series_column': DEFAULT_SERIES_COL_REINSURANCE,
                    'group_column': DEFAULT_GROUP_COL_REINSURANCE,
                    'main_insurer': DEFAULT_INSURER_REINSURANCE,
                    'compare_insurers': DEFAULT_COMPARE_INSURER_REINSURANCE,
                    'primary_y_metric': DEFAULT_PRIMARY_METRICS_REINSURANCE,
                    'secondary_y_metric': DEFAULT_SECONDARY_METRICS_REINSURANCE,
                    'premium_loss_selection': DEFAULT_PREMIUM_LOSS_TYPES_REINSURANCE
        
                })
            elif show_data_table:
                default_returns.update({
                    'x_column': DEFAULT_X_COL_TABLE,
                    'series_column': DEFAULT_SERIES_COL_TABLE,
                    'group_column': DEFAULT_GROUP_COL_TABLE,
                    'main_insurer': DEFAULT_INSURER_TABLE,
                    'compare_insurers': DEFAULT_COMPARE_INSURER_TABLE,
                    'primary_y_metric': DEFAULT_PRIMARY_METRICS_TABLE,
                    'secondary_y_metric': DEFAULT_SECONDARY_METRICS_TABLE,
                    'premium_loss_selection': DEFAULT_PREMIUM_LOSS_TYPES_TABLE
        
                })

            else:
                default_returns.update({
                    'x_column': DEFAULT_X_COL_INSURANCE,
                    'series_column': DEFAULT_SERIES_COL_INSURANCE,
                    'group_column': DEFAULT_GROUP_COL_INSURANCE,
                    'main_insurer': DEFAULT_INSURER,
                    'compare_insurers': DEFAULT_COMPARE_INSURER,
                    'primary_y_metric': DEFAULT_PRIMARY_METRICS,
                    'secondary_y_metric': DEFAULT_SECONDARY_METRICS,
                    'premium_loss_selection': DEFAULT_PREMIUM_LOSS_TYPES

                })


 
        
        else: 
            raise PreventUpdate
            

        return list(default_returns.values())

================
File: app/table_styles.py
================
# styles.py

from dash import dash_table
import pandas as pd
from typing import List, Dict, Any, Tuple, Optional, Union
import logging
from dash.dash_table.Format import Format, Scheme, Group
from constants.translations import translate
from constants.filter_options import METRICS
import re
from constants.mapping import map_insurer

from logging_config import get_logger
logger = get_logger(__name__)


COLOR_PALETTE_TABLE = {
    'primary': '#3C5A99',        # DodgerBlue for primary elements
    'secondary': '#6C757D',      # SlateGray for secondary elements
    'background': '#F8F9FA',     # White background for tables
    'text': '#212529',           # Dark text for readability
    'success': '#28a745',        # Green for positive indicators
    'danger': '#dc3545',         # Red for negative indicators
    'highlight': '#FFFFE0',      # LightYellow for summary rows
    'sohags_highlight': '#D4EDDA',  # PaleGreen for "СОГАЗ" row
    'qtoq_background': '#E9ECEF',    # LightBlue for q_to_q_change columns
    'insurer_background': '#F1F3F5', # LightSkyBlue for 'insurer' and 'N' columns
}

FONT_STYLES = {
    'family': 'Arial, sans-serif',
    'size': {
        'small': '10px',
        'medium': '10px',
        'large': '10px',
    },
}



def get_data_table_styles() -> Dict[str, Any]:
    return {
        'style_table': {
            'overflowX': 'auto',
            'backgroundColor': COLOR_PALETTE_TABLE['background'],
            'boxShadow': '0 4px 6px rgba(0, 0, 0, 0.1)',
            'borderRadius': '8px',
        },
        'style_cell': {
            'textAlign': 'left',
            'padding': '12px',
            'border': f'1px solid {COLOR_PALETTE_TABLE["secondary"]}',
            'fontSize': FONT_STYLES['size']['medium'],
            'fontFamily': FONT_STYLES['family'],
            'color': COLOR_PALETTE_TABLE['text'],
            'whiteSpace': 'normal',
            'height': 'auto',
        },
        'style_header': {
            'backgroundColor': COLOR_PALETTE_TABLE['primary'],
            'color': 'white',
            'fontWeight': 'bold',
            'textTransform': 'none',
            'borderBottom': f'2px solid {COLOR_PALETTE_TABLE["secondary"]}',
            'textAlign': 'center',
            'fontSize': FONT_STYLES['size']['medium'],
            'height': 'auto',
            'minHeight': '60px',
            'whiteSpace': 'normal',
            'position': 'relative',
            'padding': '8px 24px 8px 8px',
        },
        'style_data': {
            'backgroundColor': COLOR_PALETTE_TABLE['background'],
        },
    }

def create_conditional_style(df: pd.DataFrame) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:
    column_styles = []
    row_styles = [
        {
            'if': {'filter_query': '{insurer} contains "Топ"'},
            'backgroundColor': COLOR_PALETTE_TABLE['highlight'],
            'fontWeight': 'normal'
        },
        {
            'if': {'filter_query': '{insurer} contains "Всего"'},
            'backgroundColor': COLOR_PALETTE_TABLE['highlight'],
            'fontWeight': 'bold'
        },
        {
            'if': {'filter_query': '{insurer} contains "СОГАЗ"'},
            'backgroundColor': COLOR_PALETTE_TABLE['sohags_highlight'],
            'fontWeight': 'normal'
        },
        {
            'if': {'filter_query': '{insurer} contains "Газпром"'},
            'backgroundColor': COLOR_PALETTE_TABLE['sohags_highlight'],
            'fontWeight': 'normal'
        },
        {
            'if': {'filter_query': '{insurer} contains "КПСК"'},
            'backgroundColor': COLOR_PALETTE_TABLE['sohags_highlight'],
            'fontWeight': 'normal'
        },
    ]


    for col in df.columns:
        # Parse the column name to extract metric and additional_info
        parts = col.split('_')
        metric = None
        additional_info = ""

        for potential_metric in sorted(METRICS.keys(), key=len, reverse=True):
            if col.startswith(potential_metric):
                metric = potential_metric
                remaining_parts = col[len(metric)+1:].split('_')
                additional_info = '_'.join(remaining_parts[1:]) if len(remaining_parts) > 1 else ""
                break

        if not metric:
            metric = parts[0]
            additional_info = '_'.join(parts[2:]) if len(parts) > 2 else ""

        if is_qtoq_change_column(col, additional_info) or is_market_share_qtoq_change_column(col, additional_info):
            # Apply text color based on value
            column_styles.extend([
                {
                    'if': {
                        'column_id': col,
                        'filter_query': f'{{{col}}} > 0'
                    },
                    'color': COLOR_PALETTE_TABLE['success'],
                    'fontWeight': 'bold'
                },
                {
                    'if': {
                        'column_id': col,
                        'filter_query': f'{{{col}}} < 0'
                    },
                    'color': COLOR_PALETTE_TABLE['danger'],
                    'fontWeight': 'bold'
                }
            ])
            # Set background color for q_to_q_change columns
            column_styles.append({
                'if': {'column_id': col},
                'backgroundColor': COLOR_PALETTE_TABLE['qtoq_background'],
            })
        elif col.lower() in ['n', 'insurer']:
            # Different background colors for 'N' and 'insurer' columns
            bg_color = COLOR_PALETTE_TABLE['insurer_background']
            text_align = 'left' if col.lower() == 'insurer' else 'center'
            column_styles.append({
                'if': {'column_id': col},
                'backgroundColor': bg_color,
                'textAlign': text_align,
                'color': COLOR_PALETTE_TABLE['text'],  # Ensure text is readable
            })
    
    logger.debug(f"Created column styles: {column_styles}")
    logger.debug(f"Created row styles: {row_styles}")
    return column_styles, row_styles

def generate_column_width_styles(columns: List[Dict[str, Any]], METRICS: Dict[str, Dict[str, str]]) -> List[Dict[str, Any]]:
    style_cell_conditional = []
    for col in columns:
        col_id = col['id']
        style = {}

        if col_id in ['N', 'insurer']:
            if col_id == 'N':
                style = {
                    'width': '50px',
                    'minWidth': '50px',
                    'maxWidth': '50px',
                    'textAlign': 'center'
                }
            else:  # 'insurer'
                style = {
                    'width': '250px',
                    'minWidth': '250',
                    'maxWidth': '250px',
                    'textAlign': 'left'
                }
        else:
            # Parse the column ID to extract metric and additional info
            parts = col_id.split('_')
            
            # Find the longest matching metric key
            metric = None
            for potential_metric in sorted(METRICS.keys(), key=len, reverse=True):
                if col_id.startswith(potential_metric):
                    metric = potential_metric
                    break
            
            if metric:
                remaining_parts = col_id[len(metric)+1:].split('_')
                quarter = remaining_parts[0] if remaining_parts else ""
                additional_info = '_'.join(remaining_parts[1:]) if len(remaining_parts) > 1 else ""
            else:
                logger.warning(f"No matching metric found for column {col_id}")
                metric, quarter, additional_info = parts[0], parts[1] if len(parts) > 1 else "", '_'.join(parts[2:]) if len(parts) > 2 else ""

            # Determine column type and set style accordingly
            if is_percentage_column(col_id, metric) or is_market_share_column(col_id, additional_info) or is_qtoq_change_column(col_id, additional_info) or is_market_share_qtoq_change_column(col_id, additional_info):
                style = {
                    'width': '120px',
                    'minWidth': '120px',
                    'maxWidth': '120px',
                    'textAlign': 'center'
                }
            elif is_monetary_column(col_id, metric):
                style = {
                    'width': '150px',
                    'minWidth': '150px',
                    'maxWidth': '150px',
                    'textAlign': 'center'
                }
            else:
                style = {
                    'width': '150px',
                    'minWidth': '150px',
                    'maxWidth': '150px',
                    'textAlign': 'center'
                }

        style_cell_conditional.append({'if': {'column_id': col_id}, **style})
    
    return style_cell_conditional

def prepare_dash_table_data(table_insurer_pivot: pd.DataFrame, period_type: str) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]], List[Dict[str, Any]]]:
    logger.info("Starting prepare_dash_table_data")
    logger.debug(f"Input DataFrame shape: {table_insurer_pivot.shape}")
    
    table_columns = [{"name": col, "id": col} for col in table_insurer_pivot.columns]
    logger.debug(f"Created {len(table_columns)} initial table columns")
    
    table_data = table_insurer_pivot.to_dict('records')
    logger.debug(f"Converted DataFrame to {len(table_data)} records")
    
    for row in table_data:
        original_insurer = row['insurer']
        row['insurer'] = map_insurer(row['insurer'])
        logger.debug(f"Mapped insurer: {original_insurer} -> {row['insurer']}")
    
    # Identify metrics using METRICS dictionary
    metrics = []
    for col in table_insurer_pivot.columns:
        for metric in METRICS.keys():
            if col.startswith(metric):
                metrics.append(metric)
                break
    metrics = list(set(metrics))  # Remove duplicates
    logger.info(f"Identified metrics: {metrics}")
    
    # Use the updated format_table_columns function
    table_columns = format_table_columns(table_columns, table_data, METRICS, period_type)
    logger.debug(f"Formatted table columns, now have {len(table_columns)} columns")
    
    column_styles, row_styles = create_conditional_style(table_insurer_pivot)
    logger.debug(f"Created {len(column_styles)} column styles and {len(row_styles)} row styles")
    
    logger.info("Finished prepare_dash_table_data")
    return table_columns, table_data, (column_styles + row_styles)



def is_percentage_column(column_name: str, metric: str) -> bool:
    return METRICS.get(metric, {}).get('type') == 'ratio'

def is_monetary_column(column_name: str, metric: str) -> bool:
    return METRICS.get(metric, {}).get('type') == 'value'

def is_market_share_column(column_name: str, additional_info: str) -> bool:
    return additional_info == 'market_share' and 'q_to_q_change' not in additional_info

def is_qtoq_change_column(column_name: str, additional_info: str) -> bool:
    return additional_info == 'q_to_q_change' and 'market_share' not in additional_info

def is_market_share_qtoq_change_column(column_name: str, additional_info: str) -> bool:
    return additional_info == 'market_share_q_to_q_change'




def set_column_format(col_id: str, metric: str, additional_info: str) -> Dict[str, Any]:
    formatted_col = {'id': col_id, 'type': 'numeric'}
    
    if is_percentage_column(col_id, metric) or is_market_share_column(col_id, additional_info) or is_qtoq_change_column(col_id, additional_info) or is_market_share_qtoq_change_column(col_id, additional_info):
        formatted_col['format'] = Format(precision=2, scheme=Scheme.percentage)
        logger.debug(f"Set percentage format for column {col_id}")
    elif is_monetary_column(col_id, metric):
        formatted_col['format'] = Format(precision=3, scheme=Scheme.fixed, group=Group.yes, groups=3, group_delimiter=',')
        logger.debug(f"Set monetary format for column {col_id}")
    else:
        # For other numeric columns
        formatted_col['format'] = Format(precision=3, scheme=Scheme.fixed, group=Group.yes, groups=3, group_delimiter=',')
        logger.debug(f"Set default numeric format for column {col_id}")
    
    return formatted_col

def format_table_columns(columns: List[Dict[str, Any]], data: List[Dict[str, Any]], METRICS: Dict[str, Dict[str, str]], period_type: str) -> List[Dict[str, Any]]:
    logger.info(f"Starting format_table_columns with {len(columns)} columns")
    formatted_columns = []
    
    for col in columns:
        col_id = col['id']
        logger.debug(f"Processing column: {col_id}")
        
            # Handle 'N' and 'insurer' columns with two levels
        if col_id in ['N', 'insurer']:
            translated_col = translate(col_id)
            formatted_col = {'name': [translated_col, translated_col], 'id': col_id}
            logger.debug(f"Special column {col_id} formatted with two identical levels")
        else:

            # Parse the column ID to extract metric and additional info
            parts = col_id.split('_')
            
            # Find the longest matching metric key
            metric = None
            for potential_metric in sorted(METRICS.keys(), key=len, reverse=True):
                if col_id.startswith(potential_metric):
                    metric = potential_metric
                    break
            
            if metric:
                remaining_parts = col_id[len(metric)+1:].split('_')
                quarter = remaining_parts[0] if remaining_parts else ""
                additional_info = '_'.join(remaining_parts[1:]) if len(remaining_parts) > 1 else ""
            else:
                logger.warning(f"No matching metric found for column {col_id}")
                metric, quarter, additional_info = parts[0], parts[1] if len(parts) > 1 else "", '_'.join(parts[2:]) if len(parts) > 2 else ""

            logger.debug(f"Parsed column {col_id}: metric={metric}, quarter={quarter}, additional_info={additional_info}")
            
            # Translate metric and format quarter
            translated_metric = translate(METRICS[metric]['label']) if metric in METRICS else translate(metric)
            
            def translate_quarter(quarter: str) -> str:
                """Translate quarter string to Russian format."""
                year, q = quarter.split('Q')


                if period_type == 'same_q_last_year_ytd':
                    months = {
                        '1': '1Q',
                        '2': '1H',
                        '3': '9M',
                        '4': 'FY'
                    }
                
                else:                
                    months = {
                        '1': '1Q',
                        '2': '2Q',
                        '3': '3Q',
                        '4': '4Q'
                    }                
                return f"{months[q]} {year}"

            
            formatted_quarter = translate_quarter(quarter)
            
            # Determine the header levels
            if is_market_share_column(col_id, additional_info):
                level1 = f"{translated_metric} {translate('market_share')}"
                level2 = formatted_quarter
            elif is_qtoq_change_column(col_id, additional_info):
                level1 = f"{translated_metric} {translate(', млрд руб.')}"
                level2 = translate('q_to_q_change')
            elif is_market_share_qtoq_change_column(col_id, additional_info):
                level1 = f"{translated_metric} {translate('market_share')}"
                level2 = translate('q_to_q_change')            
            else:
                level1 = f"{translated_metric} {translate(', млрд руб.')}"
                level2 = formatted_quarter
            
            formatted_col = set_column_format(col_id, metric, additional_info)
            formatted_col['name'] = [level1, level2]
            
            logger.debug(f"Formatted column name: {formatted_col['name']}")
        
        formatted_columns.append(formatted_col)
    
    logger.info(f"Finished formatting {len(formatted_columns)} columns")
    return formatted_columns
    
def prepare_dash_table_data(table_insurer_pivot: pd.DataFrame, period_type: str) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]], List[Dict[str, Any]]]:
    logger.info("Starting prepare_dash_table_data")
    logger.debug(f"Input DataFrame shape: {table_insurer_pivot.shape}")
    
    table_columns = [{"name": col, "id": col} for col in table_insurer_pivot.columns]
    logger.debug(f"Created {len(table_columns)} initial table columns")
    
    table_data = table_insurer_pivot.to_dict('records')
    logger.debug(f"Converted DataFrame to {len(table_data)} records")
    
    for row in table_data:
        original_insurer = row['insurer']
        row['insurer'] = map_insurer(row['insurer'])
        logger.debug(f"Mapped insurer: {original_insurer} -> {row['insurer']}")
    
    # Identify metrics using METRICS dictionary
    metrics = []
    for col in table_insurer_pivot.columns:
        for metric in METRICS.keys():
            if col.startswith(metric):
                metrics.append(metric)
                break
    metrics = list(set(metrics))  # Remove duplicates
    logger.info(f"Identified metrics: {metrics}")
    
    # Use the updated format_table_columns function
    table_columns = format_table_columns(table_columns, table_data, METRICS, period_type)
    logger.debug(f"Formatted table columns, now have {len(table_columns)} columns")
    
    column_styles, row_styles = create_conditional_style(table_insurer_pivot)
    logger.debug(f"Created {len(column_styles)} column styles and {len(row_styles)} row styles")
    
    logger.info("Finished prepare_dash_table_data")
    return table_columns, table_data, (column_styles + row_styles)

def generate_dash_table_config(
    df: pd.DataFrame,
    period_type: str,
    columns_config: Optional[Dict[str, str]] = None,
    toggle_selected_market_share: Optional[List[str]] = None,
    toggle_selected_qtoq: Optional[List[str]] = None,
    toggle_additional_market_share: Optional[List[str]] = None,
    toggle_additional_qtoq: Optional[List[str]] = None
) -> Dict[str, Any]:
    logger.info("Starting generate_dash_table_config")
    
    # Convert toggle lists to boolean flags
    show_selected_market_share = "show" in toggle_selected_market_share if toggle_selected_market_share else False
    show_selected_qtoq = "show" in toggle_selected_qtoq if toggle_selected_qtoq else False
    show_additional_market_share = "show" in toggle_additional_market_share if toggle_additional_market_share else False
    show_additional_qtoq = "show" in toggle_additional_qtoq if toggle_additional_qtoq else False

    table_columns, table_data, style_data_conditional = prepare_dash_table_data(df, period_type)

    
    visible_columns = []
    hidden_columns = []
    
    for col in table_columns:
        col_id = col['id']
        col['hideable'] = True
        show_column = True
        
        metric = None
        additional_info = ""
        for potential_metric in sorted(METRICS.keys(), key=len, reverse=True):
            if col_id.startswith(potential_metric):
                metric = potential_metric
                remaining_parts = col_id[len(metric)+1:].split('_')
                additional_info = '_'.join(remaining_parts[1:]) if len(remaining_parts) > 1 else ""
                break
        
        logger.debug(f"Parsed column {col_id}: metric={metric}, additional_info={additional_info}")
        
        if metric:
            if is_market_share_column(col_id, additional_info):
                if not show_selected_market_share:
                    show_column = False
            elif is_qtoq_change_column(col_id, additional_info):
                if not show_selected_qtoq:
                    show_column = False
            elif is_market_share_qtoq_change_column(col_id, additional_info):
                if not show_selected_market_share or not show_selected_qtoq:
                    show_column = False
        
        if show_column:
            visible_columns.append(col_id)
            logger.debug(f"Column {col_id} set to visible")
        else:
            hidden_columns.append(col_id)
            logger.info(f"Column {col_id} set to hidden")
    
    logger.info(f"Visible columns: {visible_columns}")
    logger.info(f"Hidden columns: {hidden_columns}")
    
    style_cell_conditional = generate_column_width_styles(table_columns, METRICS)
    table_styles = get_data_table_styles()


    # Add style for merging 'N' and 'insurer' headers and aligning 'insurer' to the left
    # Updated header conditional styles
    style_header_conditional = [
        # Styles for N and insurer columns
        {
            'if': {'column_id': col, 'header_index': 0},
            'borderBottom': 'none',
            'paddingBottom': '0px',
        } for col in ['N', 'insurer']
    ] + [
        {
            'if': {'column_id': col, 'header_index': 1},
            'borderTop': 'none',
            'paddingTop': '0px',
            'color': 'transparent'
        } for col in ['N', 'insurer']
    ] + [
        # General header styles for all other columns
        {
            'if': {'column_id': col},
            'position': 'relative',
            'paddingRight': '36px',  # Space for sort button
        } for col in df.columns if col not in ['N', 'insurer']
    ]

    # Custom CSS for header layout
    css = [
        {
            'selector': '.dash-table-container .dash-header-cell-value',
            'rule': '''
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 42px;
                text-align: center;
                width: calc(100% - 24px);
                margin: 0 auto;
            '''
        },
        {
            'selector': '.dash-header-cell--sort',
            'rule': '''
                position: absolute !important;
                right: 8px !important;
                top: 50% !important;
                transform: translateY(-50%) !important;
            '''
        },
        {
            'selector': '.dash-header-cell-value',
            'rule': 'padding: 8px 24px 8px 8px !important;'
        }
    ]

    table_styles = get_data_table_styles()
    style_cell_conditional = generate_column_width_styles(table_columns, METRICS)

    config = {
        'columns': table_columns,
        'data': table_data,
        'style_table': table_styles['style_table'],
        'style_cell': table_styles['style_cell'],
        'style_header': table_styles['style_header'],
        'style_header_conditional': style_header_conditional,
        'style_data': table_styles['style_data'],
        'style_cell_conditional': style_cell_conditional,
        'style_data_conditional': style_data_conditional,
        'sort_action': 'native',
        'sort_mode': 'multi',
        'filter_action': 'none',
        'merge_duplicate_headers': True,
        'hidden_columns': hidden_columns,
        'sort_as_null': ['', 'No answer', 'No Answer', 'N/A', 'NA'],
        'css': css,
    }
    
    return config


logger.debug("Styles module loaded successfully")

__all__ = ['format_table_columns','get_data_table_styles', 
           'create_conditional_style',
           'prepare_dash_table_data', 'generate_dash_table_config']

================
File: app.py
================
# app.py
import dash
from dash import dcc, Input, Output, State, ALL, MATCH, dash_table, html
from dash.exceptions import PreventUpdate
from dash.dash_table.Format import Format, Scheme, Group, Sign
import inspect
import dash_bootstrap_components as dbc
from app import *
import pandas as pd
import numpy as np
from typing import Any, Callable, Dict, List, Optional, Tuple, Union
import traceback
import json
from functools import lru_cache
import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from memory_profiler import LogFile, profile
from app import *
from functools import lru_cache
from constants.filter_options import METRICS, base_metrics, calculated_metrics, calculated_ratios, calculated_metrics_options
from logging_config import setup_logging, set_debug_level, DebugLevels, get_logger, debug_log, intensive_debug_log, custom_profile
import logging
from dash import Dash, html, dcc, clientside_callback, Input, Output
from plotly.graph_objects import Figure
from data_process.data_utils import process_inputs
from data_process.process_filters import MetricsProcessor
from memory_management import memory_manager, monitor_memory, chunk_processor

from charting.chart import create_chart
from config import DATA_FILE_158
from default_values import (DEFAULT_X_COL_INSURANCE,
           DEFAULT_SERIES_COL_INSURANCE,
           DEFAULT_GROUP_COL_INSURANCE,
           DEFAULT_INSURER,
           DEFAULT_COMPARE_INSURER,
           DEFAULT_PRIMARY_METRICS,
           DEFAULT_SECONDARY_METRICS)          
            


def create_dash_app() -> dash.Dash:
    """Create and configure the Dash application for insurance data analysis."""
    
    app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP], suppress_callback_exceptions=True)
    app.title = APP_TITLE
    app.index_string = f'''
    <!DOCTYPE html>
    <html>
        <head>
            {{%metas%}}
            <title>{{%title%}}</title>
            {{%favicon%}}
            {{%css%}}
        </head>
        <body>
            {{%app_entry%}}
            <footer>
                {{%config%}}
                {{%scripts%}}
                {{%renderer%}}
            </footer>
        </body>
    </html>
    '''
    return app


def main():
    # Set up logging
    setup_logging(console_level=logging.INFO, file_level=logging.DEBUG)

    # Set the initial debug level for logging
    if DEBUG_MODE:
        set_debug_level(DebugLevels.VERBOSE)
    else:
        set_debug_level(DebugLevels.BASIC)

    # Get a logger for the main app
    logger = get_logger(__name__)

    logger.info("Starting the Insurance Data Analysis Dashboard")
    debug_log(logger, "Initializing data loading process")
    logger.info("Starting data loading...")
    insurance_df = load_and_preprocess_data(DATA_FILE_NEW)
    logger.info("Data loading completed")
    #insurance_df_158 = load_and_preprocess_data(DATA_FILE_158) 
    #reinsurance_df = load_and_preprocess_data(DATA_FILE_REINSURANCE)
    #logger.warning(f"Unique insurers insurance_df after process filters: {insurance_df['insurer'].unique().tolist()}")
    #logger.debug(f"Unique linemains in reinsurance_df: {reinsurance_df['linemain'].unique().tolist()}")
    #logger.debug(f"Unique linemains in insurance_df: {insurance_df['linemain'].unique().tolist()}")

    logger.info("Creating year quarter options...")
    year_quarter_options = create_year_quarter_options(insurance_df)
    logger.info("Year quarter options created")
    logger.info("Creating Dash app...")
    app = create_dash_app()
    logger.info("Dash app created")
    logger.info("Creating app layout...")
    app.layout = create_app_layout(
        year_quarter_options=year_quarter_options,
    )
    logger.info("App layout created")
    logger.info("Starting callback setup...")
   
    logger.info("Setting up layout callbacks...")
    setup_layout_callbacks(app)
    logger.info("Layout callbacks setup complete")
    
    logger.info("Setting up tab state callbacks...")
    setup_tab_state_callbacks(app)
    logger.info("Tab state callbacks setup complete")
    
    logger.info("Setting up checklist callbacks...")
    setup_checklist_callbacks(app)
    logger.info("Checklist callbacks setup complete")
    
    logger.info("Setting up filter callbacks...")
    setup_filter_values_callbacks(app)
    logger.info("Filter callbacks setup complete")
    
    logger.info("Setting up button callbacks...")
    setup_button_callbacks(app)
    logger.info("Button callbacks setup complete")
    
    logger.info("All callbacks setup complete")
    logger.info("Dashboard layout created")
   
       
  
            
    @app.callback(
        [
            Output('data-table', 'children'),
            Output('x-column', 'options'),
            Output('series-column', 'options'),
            Output('group-column', 'options'),
            Output('main-insurer', 'options'),
            Output('compare-insurers-main', 'options'),
            Output('primary-y-metric', 'options'),
            Output('secondary-y-metric', 'options'),
            
            #Output('table-selected-metric', 'options'),
            Output('table-title-row1', 'children'),
            Output('table-title-row2', 'children'),
            Output('stored-charts-container', 'children'),
            Output('chart-count', 'data'),
            Output('working-chart-container', 'children'),
        ],
        [
            Input('show-data-table', 'data'),
            Input('x-column', 'value'),
            Input('series-column', 'value'),
            Input('group-column', 'value'),
            Input('main-insurer', 'value'),
            Input('compare-insurers-main', 'value'),
            Input('primary-y-metric', 'value'),
            Input('secondary-y-metric', 'value'),
            Input('show-reinsurance-chart', 'data'),
            Input('number-of-insurers', 'value'),   
            Input('period-type', 'data'),
            Input('number-of-years-to-show', 'value'),
            Input('start-quarter', 'value'),
            Input('end-quarter', 'value'),
            Input('quarter-value-output', 'data'),
            Input('selected-categories-store', 'data'),
            Input('premium-loss-checklist','value'),
            Input('reinsurance-geography-dropdown', 'value'),
            Input('reinsurance-form-dropdown', 'value'),
            Input('reinsurance-type-dropdown', 'value'),
            Input('primary-chart-type', 'value'),
            Input('secondary-chart-type', 'value'),
            Input('group-series-toggle', 'value'),
            Input('stacking-groups-toggle', 'value'),
            Input('stacking-series-toggle', 'value'),
            Input('show-percentage-toggle', 'value'),
            Input('show-100-percent-toggle', 'value'),
            Input('random-color-toggle', 'value'),
            Input('store-chart-button', 'n_clicks'),
            Input('clear-charts-button', 'n_clicks'),
            #Input('table-selected-metric', 'value'),
            Input('toggle-selected-market-share', 'value'),
            Input('toggle-selected-qtoq', 'value'),
            Input('toggle-additional-market-share', 'value'),
            Input('toggle-additional-qtoq', 'value'),
            Input('number-of-periods-data-table', 'value')
        ],
        [
            State('chart-count', 'data'),
            State('stored-charts-container', 'children'),
            State('working-chart-container', 'children'),  
        ]
        )
    #@profile
    def update_dashboard(
            show_data_table, x_column, series_column, group_column,
            main_insurer, compare_insurers, primary_y_metric, secondary_y_metric,
            show_reinsurance_chart, number_of_insurers, period_type, num_periods,
            start_quarter, end_quarter, quarter_value, selected_linemains,
            
            premium_loss_selection, reinsurance_geography, reinsurance_form,
            reinsurance_type, primary_chart_type, secondary_chart_type,
            
            group_by_series, is_groups_stacked, is_series_stacked,
            show_percentage, show_100_percent, random_color,
            create_clicks, clear_clicks, #table_selected_metric,
            toggle_selected_market_share, toggle_selected_qtoq,
            toggle_additional_market_share, toggle_additional_qtoq,
            num_periods_table, 
            chart_count, stored_charts, working_chart,
            top_n_list=[5, 10, 20]):
    

        
        
        primary_y_metric, secondary_y_metric, chart_selected_metric, table_selected_metric, main_insurer, compare_insurers, selected_insurers, chart_columns = process_inputs(primary_y_metric, secondary_y_metric, main_insurer, compare_insurers, x_column, series_column, group_column)
        #logger.warning(f"selected_insurers {selected_insurers}")    
        processor = MetricsProcessor()
       
        df, insurer_options, compare_options, selected_insurers = processor.process_general_filters(insurance_df if show_data_table else reinsurance_df if show_reinsurance_chart else insurance_df, show_data_table, premium_loss_selection, (table_selected_metric or ['direct_premiums']) if show_data_table else chart_selected_metric, selected_linemains, period_type, start_quarter, end_quarter, num_periods=num_periods_table if show_data_table else num_periods, quarter_value=quarter_value, chart_columns=chart_columns, selected_insurers=selected_insurers if not show_data_table and not show_reinsurance_chart else None, reinsurance_form=reinsurance_form, reinsurance_geography=reinsurance_geography, reinsurance_type=reinsurance_type,  number_of_insurers=number_of_insurers, top_n_list=top_n_list, main_insurer=main_insurer)
        
        primary_y_metric_options, secondary_y_metric_options, table_metric_options, x_column_options, series_column_options, group_column_options = get_filter_options(df, primary_y_metric, secondary_y_metric, table_selected_metric, show_reinsurance_chart, x_column, series_column, group_column, main_insurer, top_n_list, table_selected_metric if show_data_table else chart_selected_metric, base_metrics, number_of_insurers, premium_loss_selection)
        
        #df = get_processed_df(df, selected_insurers, top_n_list, show_data_table, table_selected_metric if show_data_table else chart_selected_metric, base_metrics, calculated_metrics_options, num_periods_table if show_data_table else num_periods, period_type)

        # Initialize default returns
        default_returns = {
            'data_table': dash.no_update,
            'x_column_options': x_column_options,
            'series_column_options': series_column_options,
            'group_column_options': group_column_options,
            'main_insurer_options': insurer_options,
            'compare_options': compare_options,
            'primary_y_metric_options': table_metric_options if show_data_table else primary_y_metric_options,
            'secondary_y_metric_options': secondary_y_metric_options,            
            
            #'table_metrics_options': table_metric_options,
            'table_title_row1': dash.no_update,
            'table_title_row2': dash.no_update,
            'stored_charts': stored_charts or [],
            'chart_count': chart_count or 0,
            'working_chart': working_chart or html.Div()
        }


        ctx = dash.callback_context
        trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]
        logger.warning(f"trigger_id {trigger_id}")    
        logger.warning(f"show_data_table {show_data_table}")    
        logger.warning(f"show_reinsurance_chart {show_reinsurance_chart}")    
       
        if show_data_table:
            save_df_to_csv(df, f"df_before_table_data.csv")

            table_data = get_data_table(
                df, table_selected_metric, selected_linemains,
                period_type, number_of_insurers, toggle_selected_market_share,
                toggle_selected_qtoq, toggle_additional_market_share, toggle_additional_qtoq
            )
            
            data_table, table_title_row1, table_title_row2 = table_data
            
            default_returns.update({
                'data_table': data_table,
                'table_title_row1': table_title_row1,
                'table_title_row2': table_title_row2
            })
            return list(default_returns.values())
    
        else:   
            
            chart_data = get_chart_data(
                df, chart_selected_metric, selected_linemains, premium_loss_selection,
                period_type, x_column, series_column, group_column, start_quarter, end_quarter, 
                num_periods, is_groups_stacked, is_series_stacked, group_by_series,
                main_insurer=['total'] if show_reinsurance_chart else main_insurer,
                selected_insurers=selected_insurers,
                number_of_insurers=number_of_insurers,
                top_n_list=top_n_list,
                reinsurance_form=reinsurance_form,
                reinsurance_geography=reinsurance_geography,
                reinsurance_type=reinsurance_type
            )
            chart_data.to_csv('chart_data.csv')
            
            '''chart_figure = create_chart(
                chart_data, premium_loss_selection, selected_linemains,
                primary_y_metric, primary_chart_type, period_type,
                start_quarter, end_quarter, main_insurer, compare_insurers,
                secondary_y_metric, secondary_chart_type,
                is_groups_stacked, is_series_stacked,
                show_percentage, show_100_percent, group_by_series,
                x_column, series_column, group_column, random_color
            )
            
            working_chart = html.Div(
                dcc.Graph(
                    id={'type': 'dynamic-chart', 'index': f'chart-{chart_count}'},
                    figure=chart_figure,
                    style={'height': '700px'}
                ),
                className='working-chart'
            )'''             

            working_chart, stored_charts, chart_count = [], [], 0
            
            if trigger_id == 'clear-charts-button':
                stored_charts, chart_count = [], 0
                
            if trigger_id == 'store-chart-button':
                chart_count = (chart_count or 0) + 1
                
                stored_charts.append(working_chart)                        
                                    
            #logger.warning(f"working_chart {working_chart}")
 

            '''log_chart_structure(
                    chart_figure,
                    logger,
                    series_column,
                    group_column,
                    x_column
            )'''
                
            default_returns.update({

                'stored_charts': stored_charts or [],                
                'chart_count': chart_count,
                'working_chart': working_chart

            })

        
        return list(default_returns.values())
    
        
    return app
    

if __name__ == '__main__':
    app = main()
    # Add debug logs right before server start
    logger = get_logger(__name__)
    logger.info("About to start server...")
    
    # Try running with minimal options first
    app.run_server(
        debug=False,  # Disable debug mode temporarily
        port=8051,
        use_reloader=False  # Disable auto-reloader
    )
