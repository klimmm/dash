

  app_layout.py
  checklist.py
  date_range_filter.py
  filter_values_callbacks.py
app.py


================
File: app/app_layout.py
================


def setup_tab_state_callbacks(app):
    @app.callback(
        [
            Output("charts-only-components", "style"),
            Output("charts-buttons", "style"),
            Output("chart-config-button", "style"),

            Output("detailize-button-section", "style"),


            
            Output("primary-chart-type-section", "style"),
            Output("premium-loss-checklist-section", "style"),  # Changed from insurance-specific-filters
            Output("main-insurer-section", "style"),  # Changed from insurance-specific-filters
            
            
            Output("reinsurance-filters", "style"),
            Output("comparison-section", "style"),
            Output("comparison-section-wrapper", "style"),
            
            Output("data-table-content", "style"),
            Output("data-table-filters", "style"),

            
            Output("insurance-tab", "className"),
            Output("reinsurance-tab", "className"),
            Output("data-table-tab", "className"),
            Output("show-reinsurance-chart", "data"),
            Output("show-data-table", "data"),
        ],
        [
            Input("insurance-tab", "n_clicks"),
            Input("reinsurance-tab", "n_clicks"),
            Input("data-table-tab", "n_clicks"),
        ],
        [
            
            State("show-reinsurance-chart", "data"),
            State("show-data-table", "data"),
        ]
    )
    @custom_profile
    def toggle_visibility(insurance_clicks, reinsurance_clicks, data_table_clicks, 
                         is_reinsurance, is_data_table):
        ctx = dash.callback_context
        if not ctx.triggered:
            # Initial state
            return (
                {"display": "block"},  # charts-only-components
                {"display": "block"},  # charts-buttons
                {"display": "none"},  # chart-config-button
                {"display": "block"},  # detailize-button-section

                
                {"display": "block"},  # primary-chart-type-section
                {"display": "block"},  # premium-loss-checklist-section
                {"display": "block"},  # main-insurer-section

                
                {"display": "none"},   # reinsurance-filters
                {"display": "block"},  # comparison-section
                {"display": "block"},  # comparison-section-wrapper
                
                {"display": "none"},   # data-table-content
                {"display": "none"},   # data-table-filters
                
                "me-1 tab-like-button active",  # insurance-tab
                "tab-like-button",  # reinsurance-tab
                "tab-like-button",  # data-table-tab
                False,  # show-reinsurance-chart
                False,  # show-data-table
            )
        
        button_id = ctx.triggered[0]["prop_id"].split(".")[0]
        
        if button_id == "data-table-tab":
            return (
                {"display": "none"},    # charts-only-components
                
                {"display": "none"},  # charts-buttons
                {"display": "none"},  # chart-config-button
                {"display": "none"},  # detailize-button-section
                
                {"display": "none"},    # primary-chart-type-section
                {"display": "none"},    # premium-loss-checklist-section
                {"display": "none"},  # main-insurer-section
  
                {"display": "none"},    # reinsurance-filters
                {"display": "none"},    # comparison-section
                {"display": "none"},  # comparison-section-wrapper
                
                {"display": "block"},   # data-table-content
                {"display": "block"},   # data-table-filters
                
                "me-1 tab-like-button",
                "tab-like-button",
                "tab-like-button active",
                False,  # show-reinsurance-chart
                True,   # show-data-table
            )
            
        elif button_id == "insurance-tab":
            return (
                {"display": "block"},  # charts-only-components
                {"display": "block"},  # charts-buttons
                {"display": "none"},  # chart-config-button
                {"display": "block"},  # detailize-button-section
                
                {"display": "block"},  # primary-chart-type-section
                {"display": "block"},  # premium-loss-checklist-section
                {"display": "block"},  # main-insurer-section
              
                {"display": "none"},   # reinsurance-filters
                {"display": "block"},  # comparison-section
                {"display": "block"},  # comparison-section-wrapper
                
                {"display": "none"},   # data-table-content
                {"display": "none"},   # data-table-filters
                
                "me-1 tab-like-button active",
                "tab-like-button",
                "tab-like-button",
                False,  # show-reinsurance-chart
                False,  # show-data-table
            )
            
        elif button_id == "reinsurance-tab":
            return (
                {"display": "block"},  # charts-only-components
                {"display": "block"},  # charts-buttons
                {"display": "none"},  # chart-config-button

                {"display": "block"},  # detailize-button-section
                
                {"display": "block"},  # primary-chart-type-section
                {"display": "none"},   # premium-loss-checklist-section
                {"display": "none"},  # main-insurer-section

                {"display": "block"},  # reinsurance-filters
                {"display": "block"},  # comparison-section
                {"display": "none"},  # comparison-section-wrapper
                
                {"display": "none"},   # data-table-content
                {"display": "none"},   # data-table-filters
                
                "me-1 tab-like-button",
                "tab-like-button active",
                "tab-like-button",
                True,   # show-reinsurance-chart
                False,  # show-data-table
            )
        
        raise PreventUpdate

    @app.callback(
        Output("chart-config-row", "style"),
        Input("toggle-chart-config", "n_clicks"),
        State("chart-config-row", "style"),
        
    )
    @custom_profile
    def toggle_chart_config(n_clicks, current_style):
        if not n_clicks:
            return {"display": "none"}
        
        current_display = current_style.get("display", "none")
        return {"display": "block"} if current_display == "none" else {"display": "none"}
        
        # Modified callback for toggle button
    @app.callback(
        [
            Output("compare-insurers-section", "style"),
            Output("compare-metrics-section", "style"),
            Output("secondary-chart-type-section", "style"),
            Output("comparison-toggle", "active"),
        ],
        [
            Input("comparison-toggle", "n_clicks"),
        ],
        [
            State("comparison-toggle", "active")
        ]
    )
    @custom_profile
    def toggle_comparison_sections(toggle_clicks, is_active):
        ctx = dash.callback_context
        triggered_id = ctx.triggered[0]['prop_id'].split('.')[0]
        
        default_style = {"display": "none"}
        visible_style = {"display": "block"}
        
        # Toggle button clicked
        new_active_state = not is_active if triggered_id == "comparison-toggle" else is_active
                
        if new_active_state:
            return visible_style, visible_style, visible_style, new_active_state
        else:
            return default_style, default_style, default_style, new_active_state


#@custom_profile

def setup_button_callbacks(app):
    @app.callback(
        [Output(id, 'className') for id, _, _ in TOGGLE_BUTTONS],
        [Input(id, 'n_clicks') for id, _, _ in TOGGLE_BUTTONS],
        [State(id, 'className') for id, _, _ in TOGGLE_BUTTONS]
    )
    @custom_profile
    def toggle_all_buttons(*args):
        n_clicks = args[:len(TOGGLE_BUTTONS)]
        current_classes = args[len(TOGGLE_BUTTONS):]
        
        ctx = dash.callback_context
        if not ctx.triggered:
            return ['py-0 toggle-btn toggle-btn-active w-100' if value else 'py-0 toggle-btn w-100' 
                    for _, _, value in TOGGLE_BUTTONS]
        
        button_id = ctx.triggered[0]['prop_id'].split('.')[0]
        
        new_classes = list(current_classes)
        for i, (id, _, _) in enumerate(TOGGLE_BUTTONS):
            if id == button_id:
                new_classes[i] = ('py-0 toggle-btn w-100' 
                                if 'toggle-btn-active' in current_classes[i] 
                                else 'py-0 toggle-btn toggle-btn-active w-100')
        
        return new_classes

    @app.callback(
        [Output(id, 'value') for id, _, _ in TOGGLE_BUTTONS],
        [Input(id, 'className') for id, _, _ in TOGGLE_BUTTONS]
    )
    @custom_profile
    def update_switch_values(*classes):
        return ['active' in cls for cls in classes]

================
File: app/checklist.py
================


def setup_checklist_callbacks(app: dash.Dash) -> None:
    @app.callback(
        Output('selected-categories-store', 'data'),
        Output('category-dropdown', 'value'),
        
        Input({'type': 'category-checkbox', 'category_code': ALL}, 'value'),
        Input('category-dropdown', 'value'),
        
        Input('detailize-button', 'n_clicks'),
        State({'type': 'category-checkbox', 'category_code': ALL}, 'id'),
        State('selected-categories-store', 'data'),
        prevent_initial_call=True
    )
    @custom_profile    
    def update_store_and_sync_dropdown(checkbox_values, dropdown_value, detailize_clicks, checkbox_ids, current_selected):
        ctx = dash.callback_context
        trigger = ctx.triggered[0]['prop_id'].split('.')[0]
        
        logger.debug(f"update_store_and_sync_dropdown triggered by: {trigger}")
        
        if trigger == 'category-dropdown':
            new_selected = dropdown_value or []
            detailize = False   
        
        elif trigger == 'detailize-button':
            new_selected = current_selected
            detailize = True
        else:  # checkbox trigger
            new_selected = [
                id_dict['category_code'] for value, id_dict in zip(checkbox_values, checkbox_ids)
                if value and id_dict['category_code'] in category_structure
            ]
            detailize = False
        
        new_selected = handle_parent_child_selections(new_selected, category_structure, detailize)
        
        logger.debug(f"Final new selected categories: {new_selected}")
        return new_selected, new_selected


    @app.callback(
        Output('expanded-categories-store', 'data'),
        Input({'type': 'category-collapse-button', 'category_code': ALL}, 'n_clicks'),
        Input('selected-categories-store', 'data'),  # Add this input
        State({'type': 'category-collapse-button', 'category_code': ALL}, 'id'),
        State('expanded-categories-store', 'data'),
        prevent_initial_call=True
    )
    def update_expanded_categories(n_clicks_list, selected_categories, button_ids, expanded_categories):
        ctx = dash.callback_context
        if not ctx.triggered:
            raise PreventUpdate
            
        trigger = ctx.triggered[0]['prop_id']
        
        # Initialize expanded categories
        if expanded_categories is None:
            expanded_categories = []
        expanded_categories = set(expanded_categories)
        
        # If triggered by selection change, add parent categories
        if 'selected-categories-store' in trigger:
            checklist = CategoryChecklist(category_structure, selected_categories=selected_categories)
            parent_categories = checklist.parent_categories
            expanded_categories.update(parent_categories)
        else:
            # Handle manual expansion/collapse
            match = re.search(r'"category_code":"([^"]*)"', trigger)
            if match:
                category_code = match.group(1)
                if category_code in expanded_categories:
                    expanded_categories.remove(category_code)
                else:
                    expanded_categories.add(category_code)
        
        logger.debug(f"Updated expanded categories: {expanded_categories}")
        return list(expanded_categories)
    
    @app.callback(
        Output({'type': 'category-collapse', 'category_code': MATCH}, 'is_open'),
        Output({'type': 'category-collapse-button', 'category_code': MATCH}, 'children'),
        Input({'type': 'category-collapse-button', 'category_code': MATCH}, 'n_clicks'),
        State({'type': 'category-collapse', 'category_code': MATCH}, 'is_open'),
    )
    @custom_profile    
    def toggle_category_collapse(n_clicks, is_open):
        if not n_clicks:
            raise PreventUpdate
    
        ctx = dash.callback_context
        logger.warning(f"toggle_category_collapse ctx: {ctx}")
    
        if not ctx.triggered:
            raise PreventUpdate
    
        triggered_id = ctx.triggered[0]['prop_id']
        logger.warning(f"Full triggered_id: {triggered_id}")
    
        # Use regex to extract the entire category_code, including any dots
        match = re.search(r'"category_code":"([^"]*)"', triggered_id)
        if match:
            category_code = match.group(1)
            logger.warning(f"Extracted category_code: {category_code}")
        else:
            logger.error(f"Failed to extract category_code from: {triggered_id}")
            category_code = "Unknown"
    
        new_is_open = not is_open
        new_button_text = "▼" if new_is_open else "▶"
        
        logger.warning(f"Category: {category_code}")
        logger.warning(f"new_is_open: {new_is_open}")
        logger.warning(f"new_button_text: {new_button_text}")
        
        return new_is_open, new_button_text
        
        
    @app.callback(
        Output("category-collapse", "children"),
        Output("category-collapse", "is_open"),
        Output("toggle-all-categories", "children"),
        Input("toggle-all-categories", "n_clicks"),
        Input('selected-categories-store', 'data'),
        Input('expanded-categories-store', 'data'),
        State("category-collapse", "is_open"),
    )
    @custom_profile    
    def update_category_checklist(n_clicks, selected_categories, expanded_categories, is_open):
        ctx = dash.callback_context
        if not ctx.triggered:
            # Initial load
            return None, False, "Полный перечень"
        
        trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]
        
        logger.debug(f"update_category_checklist triggered by: {trigger_id}")
        
        if trigger_id == "toggle-all-categories":
            new_is_open = not is_open
            new_button_text = "Скрыть" if new_is_open else "Полный перечень"
        else:
            new_is_open = is_open
            new_button_text = "Скрыть" if is_open else "Полный перечень"
        
        checklist = CategoryChecklist(category_structure, selected_categories=selected_categories, expanded_categories=expanded_categories)
        return checklist.create_checklist(), new_is_open, new_button_text
     


================
File: app/date_range_filter.py
================



def setup_layout_callbacks(app):
    @app.callback(
        Output("number-of-years-to-show", "value"),
        Output("btn-1y", "className"),
        Output("btn-2y", "className"),
        Output("btn-5y", "className"),
        Output("btn-custom", "className"),
        Output("custom-range-collapse", "is_open"),
        Output("start-quarter", "value"),
        Output("end-quarter", "value"),
        Output("custom-year-input", "value"),
        [Input("btn-1y", "n_clicks"),
         Input("btn-2y", "n_clicks"),
         Input("btn-5y", "n_clicks"),
         Input("btn-custom", "n_clicks"),
         Input("btn-custom-year", "n_clicks")],
        [State("custom-year-input", "value"),
         State("number-of-years-to-show", "value"),
         State("custom-range-collapse", "is_open"),
         State("start-quarter", "value"),
         State("end-quarter", "value"),
         State("btn-1y", "className"),
         State("btn-2y", "className"),
         State("btn-5y", "className"),
         State("btn-custom", "className"),
         State("quarter-options-store", "data")]  # Add this State
    )
    @custom_profile
    def update_periods_classes_and_collapse(btn1, btn2, btn5, btn_custom, btn_custom_year, 
                                         custom_year, current_periods, is_open, 
                                         start_quarter, end_quarter, class_1y, class_2y, class_5y, class_custom,
                                         year_quarter_options):  # Add this parameter
        ctx = dash.callback_context
        if not ctx.triggered:
            initial_classes = ["py-0 btn-custom"] * 4
            initial_classes[DEFAULT_BUTTON_INDEX] = "py-0 btn-custom active"
            return DEFAULT_NUMBER_OF_PERIODS, *initial_classes, False, start_quarter, end_quarter, None

        button_id = ctx.triggered[0]['prop_id'].split('.')[0]
        periods = current_periods
        classes = ["py-0 btn-custom"] * 4

        # Get available quarters from options
        available_quarters = [opt['value'] for opt in year_quarter_options]
        available_quarters.sort()  # Ensure quarters are in chronological order
        
        def calculate_quarters(num_years):
            # Get current date to calculate target quarters
            current_date = datetime.now()
            current_year = current_date.year
            current_quarter = (current_date.month - 1) // 3 + 1
            target_end = f"{current_year}Q{current_quarter}"
            
            # Find the actual end quarter (latest available if current quarter not available)
            end_quarter = available_quarters[-1]  # Default to latest available
            for q in reversed(available_quarters):
                if q <= target_end:
                    end_quarter = q
                    break
            
            # Calculate target start quarter
            end_year = int(end_quarter.split('Q')[0])
            target_start_year = end_year - num_years
            target_start = f"{target_start_year}Q{end_quarter[-1]}"
            
            # Find the actual start quarter (earliest available if target not available)
            start_quarter = available_quarters[0]  # Default to earliest available
            for q in available_quarters:
                if q >= target_start:
                    start_quarter = q
                    break
            
            return start_quarter, end_quarter

        if button_id == "btn-custom":
            is_open = not is_open
            classes = [class_1y, class_2y, class_5y, class_custom]
            return periods, *classes, is_open, start_quarter, end_quarter, custom_year

        elif button_id == "btn-1y":
            periods = 1
            classes[0] = "py-0 btn-custom active"
            is_open = False
            start_quarter, end_quarter = calculate_quarters(1)
        
        elif button_id == "btn-2y":
            periods = 2
            classes[1] = "py-0 btn-custom active"
            is_open = False
            start_quarter, end_quarter = calculate_quarters(2)
            
        elif button_id == "btn-5y":
            periods = 5
            classes[2] = "py-0 btn-custom active"
            is_open = False
            start_quarter, end_quarter = calculate_quarters(5)
        
        elif button_id == "btn-custom-year" and custom_year:
            periods = int(custom_year)
            classes[3] = "py-0 btn-custom active"
            is_open = is_open
            start_quarter, end_quarter = calculate_quarters(periods)
        else:
            classes[3] = "py-0 btn-custom active" if is_open else "py-0 btn-custom"

        return periods, *classes, is_open, start_quarter, end_quarter, custom_year

    @app.callback(
        Output({"type": "sub-btn", "index": MATCH}, "className"),
        Input({"type": "sub-btn", "index": MATCH}, "n_clicks"),
        State('date-type-state', 'data'),
    )
    @custom_profile    
    def update_sub_button_class(n_clicks, current_state):
        if not n_clicks:
            raise dash.exceptions.PreventUpdate
        
        ctx = dash.callback_context
        button_index = eval(ctx.triggered[0]["prop_id"].split(".")[0])["index"]
        return "py-0 ms-1 btn-secondary-custom active" if button_index == current_state['sub'] else "py-0 ms-1 btn-secondary-custom"

    # Rest of get_period_type_and_quarter and other functions remain the same

    @app.callback(
        Output('date-type-state', 'data'),
        Output("collapse", "is_open"),
        Output("additional-options", "children"),
        Output({"type": "main-btn", "index": ALL}, "color"),
        Output("date-type-output", "children"),
        Output('period-type', 'data'),
        Output('quarter-value-output', 'data'),
        Input({"type": "main-btn", "index": ALL}, "n_clicks"),
        Input({"type": "sub-btn", "index": ALL}, "n_clicks"),
        State('date-type-state', 'data'),
    )
    @custom_profile
    def update_date_type_state(main_clicks, sub_clicks, current_state):
        ctx = dash.callback_context
        if not ctx.triggered:
            # Initial load
            logger.info("Initial state loaded")
            return load_initial_state()
        
        button_id = ctx.triggered[0]["prop_id"].split(".")[0]
        button_type, button_index = eval(button_id)["type"], eval(button_id)["index"]
        logger.info(f"Button clicked: {button_type} - {button_index}")

        new_state = current_state.copy()
        if button_type == "main-btn":
            new_state['main'] = button_index
            new_state['sub'] = None
        elif button_type == "sub-btn":
            new_state['sub'] = button_index

        logger.info(f"Current State - Main: {new_state['main'].upper()}, Sub: {new_state['sub'].upper() if new_state['sub'] else 'None'}")

        return generate_outputs(new_state)

    @app.callback(
        Output({"type": "sub-btn", "index": MATCH}, "color"),
        Input({"type": "sub-btn", "index": MATCH}, "n_clicks"),
        State('date-type-state', 'data'),
    )
    @custom_profile
    def update_sub_button_color(n_clicks, current_state):
        if not n_clicks:
            raise dash.exceptions.PreventUpdate
        
        ctx = dash.callback_context
        button_index = eval(ctx.triggered[0]["prop_id"].split(".")[0])["index"]
        return "success" if button_index == current_state['sub'] else "primary"

================
File: app/filter_values_callbacks.py
================


@dataclass
class FilterState:
    """Container for filter states"""
    x_column: str
    series_column: str
    group_column: str
    main_insurer: str
    compare_insurers: List[str]
    primary_y_metric: str
    secondary_y_metric: str
    premium_loss_selection: List[str]
    show_data_table: bool
    show_reinsurance_chart: bool
    
    def get_chart_columns(self) -> List[str]:
        return [self.x_column, self.series_column, self.group_column]

class FilterCallbackManager:
    def __init__(self, app: Dash):
        self.app = app
        self.defaults = self._get_default_values()
        self.register_callbacks()
        
    def _get_default_values(self) -> Dict:
        """Get default values from imported constants"""
        return {
            'X_COL': DEFAULT_X_COL_INSURANCE,
            'SERIES_COL': DEFAULT_SERIES_COL_INSURANCE,
            'GROUP_COL': DEFAULT_GROUP_COL_INSURANCE,
            'PRIMARY_METRICS': DEFAULT_PRIMARY_METRICS,
            'SECONDARY_METRICS': DEFAULT_SECONDARY_METRICS,
            'PRIMARY_METRICS_INWARD': DEFAULT_PRIMARY_METRICS_INWARD,
            'SECONDARY_METRICS_INWARD': DEFAULT_SECONDARY_METRICS_INWARD,
            'INSURANCE_DEFAULTS': {
                'x_column': DEFAULT_X_COL_INSURANCE,
                'series_column': DEFAULT_SERIES_COL_INSURANCE,
                'group_column': DEFAULT_GROUP_COL_INSURANCE,
                'main_insurer': DEFAULT_INSURER,
                'compare_insurers': DEFAULT_COMPARE_INSURER,
                'primary_y_metric': DEFAULT_PRIMARY_METRICS,
                'secondary_y_metric': DEFAULT_SECONDARY_METRICS,
                'premium_loss_selection': DEFAULT_PREMIUM_LOSS_TYPES
            },
            'REINSURANCE_DEFAULTS': {
                'x_column': DEFAULT_X_COL_REINSURANCE,
                'series_column': DEFAULT_SERIES_COL_REINSURANCE,
                'group_column': DEFAULT_GROUP_COL_REINSURANCE,
                'main_insurer': DEFAULT_INSURER_REINSURANCE,
                'compare_insurers': DEFAULT_COMPARE_INSURER_REINSURANCE,
                'primary_y_metric': DEFAULT_PRIMARY_METRICS_REINSURANCE,
                'secondary_y_metric': DEFAULT_SECONDARY_METRICS_REINSURANCE,
                'premium_loss_selection': DEFAULT_PREMIUM_LOSS_TYPES_REINSURANCE
            },
            'TABLE_DEFAULTS': {
                'x_column': DEFAULT_X_COL_TABLE,
                'series_column': DEFAULT_SERIES_COL_TABLE,
                'group_column': DEFAULT_GROUP_COL_TABLE,
                'main_insurer': DEFAULT_INSURER_TABLE,
                'compare_insurers': DEFAULT_COMPARE_INSURER_TABLE,
                'primary_y_metric': DEFAULT_PRIMARY_METRICS_TABLE,
                'secondary_y_metric': DEFAULT_SECONDARY_METRICS_TABLE,
                'premium_loss_selection': DEFAULT_PREMIUM_LOSS_TYPES_TABLE
            }
        }
    
    def register_callbacks(self):
        @self.app.callback(
            [Output('x-column', 'value'),
             Output('series-column', 'value'),
             Output('group-column', 'value'),
             Output('main-insurer', 'value'),
             Output('compare-insurers-main', 'value'),
             Output('primary-y-metric', 'value'),
             Output('secondary-y-metric', 'value'),
             Output('premium-loss-checklist', 'value')],
            [Input('show-reinsurance-chart', 'data'),
             Input('selected-categories-store', 'data'),
             Input('compare-insurers-main', 'value'),
             Input('secondary-y-metric', 'value'),
             Input('x-column', 'value'),
             Input('series-column', 'value'),
             Input('group-column', 'value'),
             Input('premium-loss-checklist', 'value')],
            [State('x-column', 'value'),
             State('series-column', 'value'),
             State('group-column', 'value'),
             State('main-insurer', 'value'),
             State('compare-insurers-main', 'value'),
             State('primary-y-metric', 'value'),
             State('secondary-y-metric', 'value'),
             State('show-data-table', 'data')]
        )
        @custom_profile
        def update_filter_values(
            show_reinsurance, selected_linemains, compare_insurers, 
            secondary_y_metric, x_col, series_col, group_col, 
            premium_loss_selection, x_col_state, series_col_state, 
            group_col_state, main_insurer_state, compare_insurers_state,
            primary_y_metric_state, secondary_y_metric_state, show_data_table
        ):
            ctx = dash.callback_context
            if not ctx.triggered:
                raise PreventUpdate

            trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]
            logger.warning(f"Filter callback triggered by: {trigger_id}")

            # Initialize with current values or defaults if None
            current_state = FilterState(
                x_column=x_col_state or self.defaults['INSURANCE_DEFAULTS']['x_column'],
                series_column=series_col_state or self.defaults['INSURANCE_DEFAULTS']['series_column'],
                group_column=group_col_state or self.defaults['INSURANCE_DEFAULTS']['group_column'],
                main_insurer=main_insurer_state or self.defaults['INSURANCE_DEFAULTS']['main_insurer'],
                compare_insurers=compare_insurers_state or self.defaults['INSURANCE_DEFAULTS']['compare_insurers'],
                primary_y_metric=primary_y_metric_state or self.defaults['INSURANCE_DEFAULTS']['primary_y_metric'],
                secondary_y_metric=secondary_y_metric_state or self.defaults['INSURANCE_DEFAULTS']['secondary_y_metric'],
                premium_loss_selection=premium_loss_selection or self.defaults['INSURANCE_DEFAULTS']['premium_loss_selection'],
                show_data_table=show_data_table,
                show_reinsurance_chart=show_reinsurance
            )

            # Add guard against circular updates for selected_categories_store
            if trigger_id == 'selected-categories-store':
                chart_columns = current_state.get_chart_columns()
                if 'linemain' in chart_columns or not selected_linemains or len(selected_linemains) <= 1:
                    raise PreventUpdate
                return self._create_response(group_column='linemain')

            try:
                if trigger_id == 'compare-insurers-main':
                    chart_columns = current_state.get_chart_columns()
                    group_column = 'insurer' if 'insurer' not in chart_columns else dash.no_update
                    return self._create_response(
                        group_column=group_column,
                        compare_insurers=compare_insurers,
                        secondary_y_metric=dash.no_update
                    )
                    
                elif trigger_id == 'secondary-y-metric':
                    chart_columns = current_state.get_chart_columns()
                    group_column = 'metric' if 'metric' not in chart_columns else dash.no_update
                    return self._create_response(
                        group_column=group_column,
                        compare_insurers=dash.no_update,
                        secondary_y_metric=secondary_y_metric
                    )
                    
                elif trigger_id in ['x-column', 'series-column', 'group-column']:
                    return self._handle_column_changes(trigger_id, current_state, x_col, series_col, group_col)
                    
                elif trigger_id == 'premium-loss-checklist':
                    return self._handle_premium_loss_changes(current_state)
                    
                elif trigger_id == 'show-reinsurance-chart':
                    return self._handle_view_type_changes(current_state)
                    
                else:
                    raise PreventUpdate

            except Exception as e:
                logger.error(f"Error in filter callback: {str(e)}")
                raise

    def _get_unique_column(self, used_cols: List[str], options: List[str]) -> str:
        """Get first available column that's not in used_cols"""
        for option in options:
            if option not in used_cols:
                return option
        return options[0]  # Fallback to first option if no unique found

    def _handle_column_changes(self, trigger_id: str, state: FilterState, 
                             x_col: str, series_col: str, 
                             group_col: str) -> List[Any]:
        """Handle changes to column selections"""
        if trigger_id == 'x-column':
            series_column = (
                state.series_column if state.series_column != x_col 
                else self.defaults['SERIES_COL'] if self.defaults['SERIES_COL'] != x_col 
                else self.defaults['X_COL']
            )
            group_column = self._get_unique_column(
                [x_col, series_column],
                [state.group_column, self.defaults['GROUP_COL'], self.defaults['X_COL'], self.defaults['SERIES_COL']]
            )
            
        elif trigger_id == 'series-column':
            x_column = (
                state.x_column if state.x_column != series_col 
                else self.defaults['X_COL'] if self.defaults['X_COL'] != series_col 
                else self.defaults['SERIES_COL']
            )
            group_column = self._get_unique_column(
                [series_col, x_column],
                [state.group_column, self.defaults['GROUP_COL'], self.defaults['SERIES_COL'], self.defaults['X_COL']]
            )
            
        elif trigger_id == 'group-column':
            x_column = (
                state.x_column if state.x_column != group_col 
                else self.defaults['X_COL'] if self.defaults['X_COL'] != group_col 
                else self.defaults['GROUP_COL']
            )
            series_column = self._get_unique_column(
                [group_col, x_column],
                [state.series_column, self.defaults['SERIES_COL'], self.defaults['GROUP_COL'], self.defaults['X_COL']]
            )
            
        return self._create_response(
            x_column=x_col if trigger_id == 'x-column' else x_column,
            series_column=series_col if trigger_id == 'series-column' else series_column,
            group_column=group_col if trigger_id == 'group-column' else group_column
        )

    def _handle_premium_loss_changes(self, state: FilterState) -> List[Any]:
        """Handle changes to premium/loss selections"""
        if 'direct' in state.premium_loss_selection:
            return self._create_response(
                primary_y_metric=self.defaults['PRIMARY_METRICS'],
                secondary_y_metric=self.defaults['SECONDARY_METRICS']
            )
        else:
            return self._create_response(
                primary_y_metric=self.defaults['PRIMARY_METRICS_INWARD'],
                secondary_y_metric=self.defaults['SECONDARY_METRICS_INWARD']
            )

    def _handle_view_type_changes(self, state: FilterState) -> List[Any]:
        """Handle changes between insurance/reinsurance/table views"""
        if state.show_reinsurance_chart:
            return self._create_response(**self.defaults['REINSURANCE_DEFAULTS'])
        elif state.show_data_table:
            return self._create_response(**self.defaults['TABLE_DEFAULTS'])
        else:
            return self._create_response(**self.defaults['INSURANCE_DEFAULTS'])

    def _create_response(self, **updates) -> List[Any]:
        """Create a response list with updates"""
        response = {
            'x_column': dash.no_update,
            'series_column': dash.no_update,
            'group_column': dash.no_update,
            'main_insurer': dash.no_update,
            'compare_insurers': dash.no_update,
            'primary_y_metric': dash.no_update,
            'secondary_y_metric': dash.no_update,
            'premium_loss_selection': dash.no_update
        }
        response.update(updates)
        return list(response.values())


def register_filter_callbacks(app: Dash) -> None:
    """Initialize filter callbacks"""
    try:
        logger.info("Initializing filter callbacks")
        FilterCallbackManager(app)
        logger.info("Successfully initialized filter callbacks")
    except Exception as e:
        logger.error(f"Error initializing filter callbacks: {str(e)}")
        raise

================
File: app.py
================

def main():
    # Set up logging
    setup_logging(console_level=logging.INFO, file_level=logging.DEBUG)

    # Set the initial debug level for logging
    if DEBUG_MODE:
        set_debug_level(DebugLevels.VERBOSE)
    else:
        set_debug_level(DebugLevels.BASIC)

    # Get a logger for the main app
    logger = get_logger(__name__)

    logger.info("Starting the Insurance Data Analysis Dashboard")
    debug_log(logger, "Initializing data loading process")
    logger.info("Starting data loading...")
    insurance_df = load_and_preprocess_data(DATA_FILE_NEW)
    logger.info("Data loading completed")
    #insurance_df_158 = load_and_preprocess_data(DATA_FILE_158) 
    #reinsurance_df = load_and_preprocess_data(DATA_FILE_REINSURANCE)
    #logger.warning(f"Unique insurers insurance_df after process filters: {insurance_df['insurer'].unique().tolist()}")
    #logger.debug(f"Unique linemains in reinsurance_df: {reinsurance_df['linemain'].unique().tolist()}")
    #logger.debug(f"Unique linemains in insurance_df: {insurance_df['linemain'].unique().tolist()}")

    logger.info("Creating year quarter options...")
    year_quarter_options = create_year_quarter_options(insurance_df)
    logger.info("Year quarter options created")
    logger.info("Creating Dash app...")
    app = create_dash_app()
    logger.info("Dash app created")
    logger.info("Creating app layout...")
    app.layout = create_app_layout(
        year_quarter_options=year_quarter_options,
    )
    logger.info("App layout created")
    logger.info("Starting callback setup...")
   
    logger.info("Setting up layout callbacks...")
    setup_layout_callbacks(app)
    logger.info("Layout callbacks setup complete")
    
    logger.info("Setting up tab state callbacks...")
    setup_tab_state_callbacks(app)
    logger.info("Tab state callbacks setup complete")
    
    logger.info("Setting up checklist callbacks...")
    setup_checklist_callbacks(app)
    logger.info("Checklist callbacks setup complete")
    
    logger.info("Setting up filter callbacks...")
    register_filter_callbacks(app)
    logger.info("Filter callbacks setup complete")
    
    logger.info("Setting up button callbacks...")
    setup_button_callbacks(app)
    logger.info("Button callbacks setup complete")
    
    logger.info("All callbacks setup complete")
    logger.info("Dashboard layout created")
   
       
  
            
    @app.callback(
        [
            Output('data-table', 'children'),
            Output('x-column', 'options'),
            Output('series-column', 'options'),
            Output('group-column', 'options'),
            Output('main-insurer', 'options'),
            Output('compare-insurers-main', 'options'),
            Output('primary-y-metric', 'options'),
            Output('secondary-y-metric', 'options'),
            
            #Output('table-selected-metric', 'options'),
            Output('table-title-row1', 'children'),
            Output('table-title-row2', 'children'),
            Output('stored-charts-container', 'children'),
            Output('chart-count', 'data'),
            Output('working-chart-container', 'children'),
        ],
        [
            Input('show-data-table', 'data'),
            Input('x-column', 'value'),
            Input('series-column', 'value'),
            Input('group-column', 'value'),
            Input('main-insurer', 'value'),
            Input('compare-insurers-main', 'value'),
            Input('primary-y-metric', 'value'),
            Input('secondary-y-metric', 'value'),
            Input('show-reinsurance-chart', 'data'),
            Input('number-of-insurers', 'value'),   
            Input('period-type', 'data'),
            Input('number-of-years-to-show', 'value'),
            Input('start-quarter', 'value'),
            Input('end-quarter', 'value'),
            Input('quarter-value-output', 'data'),
            Input('selected-categories-store', 'data'),
            Input('premium-loss-checklist','value'),
            Input('reinsurance-geography-dropdown', 'value'),
            Input('reinsurance-form-dropdown', 'value'),
            Input('reinsurance-type-dropdown', 'value'),
            Input('primary-chart-type', 'value'),
            Input('secondary-chart-type', 'value'),
            Input('group-series-toggle', 'value'),
            Input('stacking-groups-toggle', 'value'),
            Input('stacking-series-toggle', 'value'),
            Input('show-percentage-toggle', 'value'),
            Input('show-100-percent-toggle', 'value'),
            Input('random-color-toggle', 'value'),
            Input('store-chart-button', 'n_clicks'),
            Input('clear-charts-button', 'n_clicks'),
            #Input('table-selected-metric', 'value'),
            Input('toggle-selected-market-share', 'value'),
            Input('toggle-selected-qtoq', 'value'),
            Input('toggle-additional-market-share', 'value'),
            Input('toggle-additional-qtoq', 'value'),
            Input('number-of-periods-data-table', 'value')
        ],
        [
            State('chart-count', 'data'),
            State('stored-charts-container', 'children'),
            State('working-chart-container', 'children'),  
        ]
        )
    #@profile
    def update_dashboard(
            show_data_table, x_column, series_column, group_column,
            main_insurer, compare_insurers, primary_y_metric, secondary_y_metric,
            show_reinsurance_chart, number_of_insurers, period_type, num_periods,
            start_quarter, end_quarter, quarter_value, selected_linemains,
            
            premium_loss_selection, reinsurance_geography, reinsurance_form,
            reinsurance_type, primary_chart_type, secondary_chart_type,
            
            group_by_series, is_groups_stacked, is_series_stacked,
            show_percentage, show_100_percent, random_color,
            create_clicks, clear_clicks, #table_selected_metric,
            toggle_selected_market_share, toggle_selected_qtoq,
            toggle_additional_market_share, toggle_additional_qtoq,
            num_periods_table, 
            chart_count, stored_charts, working_chart,
            top_n_list=[5, 10, 20]):
    

        
        
        primary_y_metric, secondary_y_metric, chart_selected_metric, table_selected_metric, main_insurer, compare_insurers, selected_insurers, chart_columns = process_inputs(primary_y_metric, secondary_y_metric, main_insurer, compare_insurers, x_column, series_column, group_column)
        #logger.warning(f"selected_insurers {selected_insurers}")    
        processor = MetricsProcessor()
       
        df, insurer_options, compare_options, selected_insurers = processor.process_general_filters(insurance_df if show_data_table else reinsurance_df if show_reinsurance_chart else insurance_df, show_data_table, premium_loss_selection, (table_selected_metric or ['direct_premiums']) if show_data_table else chart_selected_metric, selected_linemains, period_type, start_quarter, end_quarter, num_periods=num_periods_table if show_data_table else num_periods, quarter_value=quarter_value, chart_columns=chart_columns, selected_insurers=selected_insurers if not show_data_table and not show_reinsurance_chart else None, reinsurance_form=reinsurance_form, reinsurance_geography=reinsurance_geography, reinsurance_type=reinsurance_type,  number_of_insurers=number_of_insurers, top_n_list=top_n_list, main_insurer=main_insurer)
        
        primary_y_metric_options, secondary_y_metric_options, table_metric_options, x_column_options, series_column_options, group_column_options = get_filter_options(df, primary_y_metric, secondary_y_metric, table_selected_metric, show_reinsurance_chart, x_column, series_column, group_column, main_insurer, top_n_list, table_selected_metric if show_data_table else chart_selected_metric, base_metrics, number_of_insurers, premium_loss_selection)
        
        #df = get_processed_df(df, selected_insurers, top_n_list, show_data_table, table_selected_metric if show_data_table else chart_selected_metric, base_metrics, calculated_metrics_options, num_periods_table if show_data_table else num_periods, period_type)

        # Initialize default returns
        default_returns = {
            'data_table': dash.no_update,
            'x_column_options': x_column_options,
            'series_column_options': series_column_options,
            'group_column_options': group_column_options,
            'main_insurer_options': insurer_options,
            'compare_options': compare_options,
            'primary_y_metric_options': table_metric_options if show_data_table else primary_y_metric_options,
            'secondary_y_metric_options': secondary_y_metric_options,            
            
            #'table_metrics_options': table_metric_options,
            'table_title_row1': dash.no_update,
            'table_title_row2': dash.no_update,
            'stored_charts': stored_charts or [],
            'chart_count': chart_count or 0,
            'working_chart': working_chart or html.Div()
        }


        ctx = dash.callback_context
        trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]
        logger.warning(f"trigger_id {trigger_id}")    
        logger.warning(f"show_data_table {show_data_table}")    
        logger.warning(f"show_reinsurance_chart {show_reinsurance_chart}")    
       
        if show_data_table:
            save_df_to_csv(df, f"df_before_table_data.csv")

            table_data = get_data_table(
                df, table_selected_metric, selected_linemains,
                period_type, number_of_insurers, toggle_selected_market_share,
                toggle_selected_qtoq, toggle_additional_market_share, toggle_additional_qtoq
            )
            
            data_table, table_title_row1, table_title_row2 = table_data
            
            default_returns.update({
                'data_table': data_table,
                'table_title_row1': table_title_row1,
                'table_title_row2': table_title_row2
            })
            return list(default_returns.values())
    
        else:   
            
            chart_data = get_chart_data(
                df, chart_selected_metric, selected_linemains, premium_loss_selection,
                period_type, x_column, series_column, group_column, start_quarter, end_quarter, 
                num_periods, is_groups_stacked, is_series_stacked, group_by_series,
                main_insurer=['total'] if show_reinsurance_chart else main_insurer,
                selected_insurers=selected_insurers,
                number_of_insurers=number_of_insurers,
                top_n_list=top_n_list,
                reinsurance_form=reinsurance_form,
                reinsurance_geography=reinsurance_geography,
                reinsurance_type=reinsurance_type
            )
            chart_data.to_csv('chart_data.csv')
            
            '''chart_figure = create_chart(
                chart_data, premium_loss_selection, selected_linemains,
                primary_y_metric, primary_chart_type, period_type,
                start_quarter, end_quarter, main_insurer, compare_insurers,
                secondary_y_metric, secondary_chart_type,
                is_groups_stacked, is_series_stacked,
                show_percentage, show_100_percent, group_by_series,
                x_column, series_column, group_column, random_color
            )
            
            working_chart = html.Div(
                dcc.Graph(
                    id={'type': 'dynamic-chart', 'index': f'chart-{chart_count}'},
                    figure=chart_figure,
                    style={'height': '700px'}
                ),
                className='working-chart'
            )'''             

            working_chart, stored_charts, chart_count = [], [], 0
            
            if trigger_id == 'clear-charts-button':
                stored_charts, chart_count = [], 0
                
            if trigger_id == 'store-chart-button':
                chart_count = (chart_count or 0) + 1
                
                stored_charts.append(working_chart)                        
                                    
            #logger.warning(f"working_chart {working_chart}")
 

            '''log_chart_structure(
                    chart_figure,
                    logger,
                    series_column,
                    group_column,
                    x_column
            )'''
                
            default_returns.update({

                'stored_charts': stored_charts or [],                
                'chart_count': chart_count,
                'working_chart': working_chart

            })

        
        return list(default_returns.values())
    
        
    return app
    

if __name__ == '__main__':
    app = main()
    # Add debug logs right before server start
    logger = get_logger(__name__)
    logger.info("About to start server...")
    
    # Try running with minimal options first
    app.run_server(
        debug=False,  # Disable debug mode temporarily
        port=8051,
        use_reloader=False  # Disable auto-reloader
    )
